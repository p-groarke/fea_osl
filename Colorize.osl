// Colorize - Various schemes to convert a float grayscale map to color.
// Colorize by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#include "D:\code\3dsmax-plugins\OSL\FeaOSL\fea.osl"

#define degs30 0.0833333333333333
#define degs60 0.1666666666666667

// Given a hue and how many levels to output,
// returns the closest multiple.
float flattenize(float hue, float start_hue, int levels) {
	if (!levels) {
		return hue;
	}

	float multiple = 1.0 / float(levels);
	return ceil(hue / multiple) * multiple;
}

float flattenize(float hue, int levels) {
	return flattenize(hue, 0.0, levels);
}

// Returns a value between [0,1] the contour strength.
float contourize(float before_flatten, float after_flatten, float width, int soften, float soften_slope, int levels) {
	if (!levels) {
		return 0.0;
	}

	if (after_flatten == 0.0 || after_flatten == 1.0) {
		return 0.0;
	}

	float multiple = 1.0 / float(levels);
	float diff = after_flatten - before_flatten;

	if (diff > width && diff < multiple - width) {
		return 0.0;
	}

	if (!soften) {
		return 1.0;
	}

	// flip "inward" side
	if (diff >= multiple - width) {
		diff = multiple - diff;
	}

	float rectify = 1.0 / width;
	diff *= rectify;

	float edge0 = width * soften_slope;
	float edge1 = 1.0 - width * soften_slope;
	return 1.0 - smoothstep(edge0, edge1, diff);
	// return 1.0 - fea_interp(soften_slope, diff);
}

shader Colorize
[[
	string help  =
		"<h3>Colorize</h3>"
		"Various schemes to convert a float grayscale map to color.\n"
		"Expects values between [0, 1], clamps input."
		,
	string label = "Colorize"
]]
(
	float In = 0
	[[
		string label = "In",
		string help = "Input grayscale map, expects float.",
	]],

	int in_invert = 0
	[[
		string label = "Invert",
		string help = "Flips the input values, 1 becomes 0, 0 becomes 1.",
		int connectable = 0,
		string widget = "checkBox",
	]],

	FEA_SPACER(0),

	int in_color_mode = 0
	[[
		string widget = "mapper",
		string label = "Color Mode",
		string options =
			"Simple Hue:0"
			"|Heat Map:1"
			"|Bright Burn:2"
			"|Complements:3"
			"|Analogous:4"
			"|Split-Complementary:5"
			"|Triad:6"
			"|Tetradic:7"
			"|Square:8"
			,
		string help = "The output 'Color' algorithm to use.",
		int connectable = 0,
		string packName = "Color Mode / Hue",
	]],

	float in_hue = 0
	[[
		string label = "Hue",
		string help = "Cycles through available hues.",
		// float min = 0,
		// float max = 1,
		string packName = "Color Mode / Hue",
		int widgetWidth = FEA_RPACK_W,
	]],

	int in_flat = 0
	[[
		string label = "Flatten",
		string help = "Outputs 'hard' colors, without gradient.",
		int connectable = 0,
		string widget = "checkBox",
		// string packName = "Num Flat Levels / Flatten",
		// int widgetWidth = FEA_RPACK_W,
	]],

	int in_num_flat_lvls = 6
	[[
		string label = "Num Flat Levels",
		string help = "The number of colors to use in 'flat mode'. More colors == more precision.",
		int connectable = 0,
		int min = 1,
		// string packName = "Num Flat Levels / Flatten",
	]],

	FEA_SPACER(1),

	int in_contours = 0
	[[
		string label = "Contour Lines",
		string help = "Draw contours / edges according to number of levels.",
		int connectable = 0,
		string widget = "checkBox",
		string packName = "Contour Lines / Width",
	]],

	float in_contour_width = 1.0
	[[
		string label = "Contour Width",
		string help = "The contour width.",
		int connectable = 0,
		float min = 0.0001,
		string packName = "Contour Lines / Width",
		int widgetWidth = FEA_RPACK_W,
	]],

	int in_smooth_contours = 0
	[[
		string label = "Soften Contour",
		string help = "Soften edges of contour lines.",
		int connectable = 0,
		string widget = "checkBox",
		string packName = "Soften Contours / Slope",
	]],

	float in_smooth_contour_slope = 1.0
	[[
		string label = "Soften Contour Slope",
		string help = "The size of the softening gradient. Positive is exponential, negative is logarithmic and '0' is linear interpolation (none).",
		int connectable = 0,
		// float min = 0.0001,
		string packName = "Soften Contours / Slope",
		int widgetWidth = FEA_RPACK_W,
	]],

	output color Out = 0
)
{
	float val = clamp(In, 0.0, 1.0);
	val = in_invert ? 1.0 - val : val;

	// float hue = fmod(in_hue, 1.0);
	float hue = in_hue;
	float hsv_v = 1.0;
	float before_flatten = val;

	int flatten_levels = in_num_flat_lvls;
	int contour_levels = in_num_flat_lvls;
	if (!in_flat) {
		flatten_levels = 0;
	}
	if (!in_contours) {
		contour_levels = 0;
	}

	val = flattenize(val, flatten_levels);

	hsv_v = 1.0 - contourize(before_flatten, val, in_contour_width * 0.01, in_smooth_contours, in_smooth_contour_slope, contour_levels);

	// float multiple = 1.0 / float(flatten_levels);
	// float diff = val - in_val;

	// if (val != 0.0 && val != 1.0 && (diff >= multiple - 0.01 || diff <= 0.01)) {
	// 	if (diff >= multiple - 0.01) {
	// 		diff = multiple - diff;
	// 	}
	// 	hsv_v = smoothstep(0.1, 0.9, diff * 100.0);
	// }


	color out_col;
	if (in_color_mode == 0) {
		// hsv
		// float col = fmod(val + hue, 1);
		float col = val + hue;
		out_col = color("hsv", col, 1, hsv_v);
	} else if (in_color_mode == 1) {
		// heat map
		float offset = 0.5 + degs60 + hue;
		float col = offset + val * 0.5;
		out_col = color("hsv", col, 1, hsv_v);
	} else if (in_color_mode == 2) {
		// bright burn
		float g = 0.618033988749895;
		float col = val * 0.569 + g + hue;
		float s = 1.0 - val;

		s = flattenize(s, flatten_levels);
		out_col = color("hsv", col, s, hsv_v);
	} else if (in_color_mode == 3) {
		// complements
		color start_col = color("hsv", hue, 1, 1);
		color end_col = color("hsv", 0.5 + hue, 1, 1);
		out_col = mix(start_col, end_col, val);
	} else if (in_color_mode == 4) {
		// analogous
		float col = fmod(val * degs60 + hue, 1) ;
		out_col = color("hsv", col, 1, 1);
	} else if (in_color_mode == 5) {
		// split complementary
		color c1 = color("hsv", hue, 1, 1);
		color c2 = color("hsv", 0.5 + degs30 + hue, 1, 1);
		color c3 = color("hsv", 0.5 - degs30 + hue, 1, 1);
		out_col = fea_mix(c1, c2, c3, val);
	} else if (in_color_mode == 6) {
		// triad
		color c1 = color("hsv", hue, 1, 1);
		color c2 = color("hsv", 0.25 + degs30 + hue, 1, 1);
		color c3 = color("hsv", 0.75 - degs30 + hue, 1, 1);
		out_col = fea_mix(c1, c3, c2, val);
	} else if (in_color_mode == 7) {
		// tetradic
		color c1 = color("hsv", (1 / 12.0) + hue, 1, 1);
		color c2 = color("hsv", 0.5 - degs30 + hue, 1, 1);
		color c3 = color("hsv", 0.5 + degs30 + hue, 1, 1);
		color c4 = color("hsv", 1.0 - degs30 + hue, 1, 1);
		out_col = fea_mix(c1, c4, c2, c3, val);
	} else if (in_color_mode == 8) {
		// square
		color c1 = color("hsv", hue, 1, 1);
		color c2 = color("hsv", 0.25 + hue, 1, 1);
		color c3 = color("hsv", 0.5 + hue, 1, 1);
		color c4 = color("hsv", 0.75 + hue, 1, 1);
		out_col = fea_mix(c1, c3, c4, c2, val);
	}

	Out = out_col;
}