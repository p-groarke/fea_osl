// Grayscale To Color - Various schemes to convert a float grayscale map to color.
// Grayscale To Color by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#include "D:\code\3dsmax-plugins\OSL\FeaOSL\fea.osl"

#define degs30 0.0833333333333333
#define degs60 0.1666666666666667

shader GrayscaleToColor
[[
	string help  =
		"<h3>Grayscale To Color</h3>"
		"Various schemes to convert a float grayscale map to color.\n"
		"Expects values between [0, 1], clamps input."
		,
	string label = "Grayscale To Color"
]]
(
	float In = 0
	[[
		string label = "In",
		string help = "Input grayscale map, expects float.",
	]],


	int color_mode = 0
	[[
		string widget = "mapper",
		string label = "Color Mode",
		string options =
			"Simple Hue:0"
			"|Heat Map:1"
			"|Bright Burn:2"
			"|Complements:3"
			"|Analogous:4"
			"|Split-Complementary:5"
			"|Triad:6"
			"|Tetradic:7"
			"|Square:8"
			,
		string help = "The output 'Color' algorithm to use.",
		int connectable = 0,
		string packName = "Color Mode / Hue",
	]],

	float hue_in = 0
	[[
		string label = "Hue",
		string help = "Cycles through available hues.",
		// float min = 0,
		// float max = 1,
		string packName = "Color Mode / Hue",
		int widgetWidth = FEA_RPACK_W,
	]],

	int invert = 0
	[[
		string label = "Invert",
		string help = "Flips the input values, 1 becomes 0, 0 becomes 1.",
		int connectable = 0,
		string widget = "checkBox",
	]],

	output color Out = 0
)
{
	float val = clamp(In, 0.0, 1.0);
	val = invert ? 1.0 - val : val;

	float hue = fmod(hue_in, 1.0);

	color out_col;
	if (color_mode == 0) {
		// hsv
		float col = fmod(val + hue, 1);
		out_col = color("hsv", col, 1, 1);
	} else if (color_mode == 1) {
		// heat map
		float col = fmod(0.5 + degs60 + val * 0.5 + hue, 1);
		out_col = color("hsv", col, 1, 1);
	} else if (color_mode == 2) {
		// bright burn
		float g = 0.618033988749895;
		float col = fmod((val * 0.569) + g + hue, 1);
		out_col = color("hsv", col, 1 - val, 1);
	} else if (color_mode == 3) {
		// complements
		color start_col = color("hsv", hue, 1, 1);
		color end_col = color("hsv", 0.5 + hue, 1, 1);
		out_col = mix(start_col, end_col, val);
	} else if (color_mode == 4) {
		// analogous
		float col = fmod(val * degs60 + hue, 1) ;
		out_col = color("hsv", col, 1, 1);
	} else if (color_mode == 5) {
		// split complementary
		color c1 = color("hsv", hue, 1, 1);
		color c2 = color("hsv", 0.5 + degs30 + hue, 1, 1);
		color c3 = color("hsv", 0.5 - degs30 + hue, 1, 1);
		out_col = fea_mix(c1, c2, c3, val);
	} else if (color_mode == 6) {
		// triad
		color c1 = color("hsv", hue, 1, 1);
		color c2 = color("hsv", 0.25 + degs30 + hue, 1, 1);
		color c3 = color("hsv", 0.75 - degs30 + hue, 1, 1);
		out_col = fea_mix(c1, c3, c2, val);
	} else if (color_mode == 7) {
		// tetradic
		color c1 = color("hsv", (1 / 12.0) + hue, 1, 1);
		color c2 = color("hsv", 0.5 - degs30 + hue, 1, 1);
		color c3 = color("hsv", 0.5 + degs30 + hue, 1, 1);
		color c4 = color("hsv", 1.0 - degs30 + hue, 1, 1);
		out_col = fea_mix(c1, c4, c2, c3, val);
	} else if (color_mode == 8) {
		// square
		color c1 = color("hsv", hue, 1, 1);
		color c2 = color("hsv", 0.25 + hue, 1, 1);
		color c3 = color("hsv", 0.5 + hue, 1, 1);
		color c4 = color("hsv", 0.75 + hue, 1, 1);
		out_col = fea_mix(c1, c3, c4, c2, val);
	}

	Out = out_col;
}