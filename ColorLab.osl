// ColorScheme - Various schemes to convert a float grayscale map to color.
// ColorScheme by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_widget.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_color.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_algorithm.osl"

#define degs30 0.0833333333333333
#define degs60 0.1666666666666667

// TO MOVE

// Given x, an alpha constant (0.5 == centripetal), and 4 points.
// Computes the catmull-rom interpolation of the point at x.
//
// https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline
point fea_catmull_rom(float x, float alpha,
		point p0, point p1, point p2, point p3) {

	float get_t(float y, float alpha, point p0, point p1) {
		vector dir = p1 - p0;
		float a = dot(dir, dir); // sqr mag
		float b = pow(a, alpha * 0.5);
		return b + y;
	}

	// Get the tees.
	// This effectively remaps (or transforms) the knot positions
	// into a not-necessarily-uniform space.
	// Which gives more or less importance to the curves before
	// and after our desired segment.
	float t0 = 0.0;
	float t1 = get_t(t0, alpha, p0, p1);
	float t2 = get_t(t1, alpha, p1, p2);
	float t3 = get_t(t2, alpha, p2, p3);
	float t = fea_lerp(x, t1, t2);

	// Weigh the points given t's percentage (or inverse percentage)
	// along the ranges.
	point a1 = fea_per_inv(t, t0, t1) * p0 + fea_per(t, t0, t1) * p1;
	point a2 = fea_per_inv(t, t1, t2) * p1 + fea_per(t, t1, t2) * p2;
	point a3 = fea_per_inv(t, t2, t3) * p2 + fea_per(t, t2, t3) * p3;
	point b1 = fea_per_inv(t, t0, t2) * a1 + fea_per(t, t0, t2) * a2;
	point b2 = fea_per_inv(t, t1, t3) * a2 + fea_per(t, t1, t3) * a3;
	point c  = fea_per_inv(t, t1, t2) * b1 + fea_per(t, t1, t2) * b2;
	return c;
}

float fea_catmull_rom(float x, float alpha,
		float p0, float p1, float p2, float p3) {

	float get_t(float y, float alpha, float p0, float p1) {
		float dir = p1 - p0;
		float a = dir * dir; // sqr mag
		float b = pow(a, alpha * 0.5);
		return b + y;
	}

	// Get the tees.
	float t0 = 0.0;
	float t1 = get_t(t0, alpha, p0, p1);
	float t2 = get_t(t1, alpha, p1, p2);
	float t3 = get_t(t2, alpha, p2, p3);
	float t = fea_lerp(x, t1, t2);

	// Weigh the points given t's percentage (or inverse percentage)
	// along the ranges.
	float a1 = fea_per_inv(t, t0, t1) * p0 + fea_per(t, t0, t1) * p1;
	float a2 = fea_per_inv(t, t1, t2) * p1 + fea_per(t, t1, t2) * p2;
	float a3 = fea_per_inv(t, t2, t3) * p2 + fea_per(t, t2, t3) * p3;
	float b1 = fea_per_inv(t, t0, t2) * a1 + fea_per(t, t0, t2) * a2;
	float b2 = fea_per_inv(t, t1, t3) * a2 + fea_per(t, t1, t3) * a3;
	float c  = fea_per_inv(t, t1, t2) * b1 + fea_per(t, t1, t2) * b2;
	return c;
}


// Represents an absolute value knot in a gradient.
struct fea_knot_info {
	color lab; // Absolute oklab color.
	float position; // The knot position on a [0, 1] percentage ramp.
};
void fea_init(output fea_knot_info out) {
	out.lab = 0;
	out.position = 0.0;
}

#define fea_gradient_interpolation_opts \
		"Linear:0" \
		"|Staircase:1" \
		"|Catmull-Rom:2" \
		"|Monotone Cubic:3"

// Represents the "in-between" gradient of 2 knots.
struct fea_gradient_info {
	int interp_mode; // Interpolation of this gradient.
	int steps; // For staircase, 0 == constant.
	float border_width; // Staircase border width.
	color cl_boost; // Added in between knots.
};
void fea_init(output fea_gradient_info out) {
	out.interp_mode = 0;
	out.steps = 0;
	out.border_width = 1.0;
	out.cl_boost = 0;
}

fea_define_array(fea_knot_info, 4)
fea_define_array(fea_gradient_info, 3)


// Boosts the lab color according to x percent, using gradient g.
// Returns lab color.
color fea_gradient_boost(float x, fea_gradient_info g, color lab) {
	color ret = fea_transformc("oklab", "okhcl", lab);
	float w = fea_corner_inflection(x, 0.5);

	// Chroma
	ret[1] = mix(ret[1], ret[1] + g.cl_boost[1], w);

	// Lightness
	ret[2] = mix(ret[2], ret[2] + g.cl_boost[2], w);
	return fea_transformc("okhcl", "oklab", ret);
}

// Linear gradient for provided knots and gradient.
// Expects x from [0, 1].
// Returns an hcl value.
color fea_linear_gradient(float x, fea_knot_info k1, fea_gradient_info g,
		fea_knot_info k2) {
	color ret = mix(k1.lab, k2.lab, x);
	ret = fea_gradient_boost(x, g, ret);
	return ret;
}

// Staircase gradient for provided knots and gradient.
// Expects x from [0, 1].
// Returns an hcl value.
color fea_staircase_gradient(float x, fea_knot_info k1, fea_gradient_info g,
		fea_knot_info k2) {
	float p = fea_staircase_interp(x, g.steps, 0.0, 1.0);
	return fea_linear_gradient(p, k1, g, k2);
}

// Catmull-rom spline gradient for provided knots and gradient.
// Expects x from [0, 1].
// Returns an lab value.
color fea_catmull_gradient(float x, fea_knot_info k0, fea_gradient_info g0,
		fea_knot_info k1, fea_gradient_info g1,
		fea_knot_info k2, fea_gradient_info g2,
		fea_knot_info k3) {

	color c0 = k0.lab;
	color c1 = k1.lab;
	color c2 = k2.lab;
	color c3 = k3.lab;

	color ret = 0;
	for (int i = 0; i < 3; ++i) {
		// Run the interpolation in 2d, with position interpreted as x.
		point interp = fea_catmull_rom(x, 0.5,
			point(k0.position, c0[i], 0),
			point(k1.position, c1[i], 0),
			point(k2.position, c2[i], 0),
			point(k3.position, c3[i], 0)
		);

		ret[i] = interp[1];
	}

	// Also blend gradient boost with catmull-rom interpolation.
	{
		float mid_point = (k2.position - k1.position) * 0.5;
		float new_x;
		if (x < 0.5) {
			// drop k3
			new_x = fea_catmull_rom(x, 0.5,
				k0.position,
				k1.position,
				mid_point,
				k2.position
			);
		} else {
			// drop k0
			new_x = fea_catmull_rom(x, 0.5,
				k1.position,
				mid_point,
				k2.position,
				k3.position
			);
		}

		// test
		{
			// new_x = fea_per(ret[0], k1.hcl[0], k2.hcl[0]);
			// new_x = mix(k1.hcl[0], k2.hcl[0], 0.5) - ret[0];
		}

		// We have the correct x, remap that to percentage.
		float p = fea_per(new_x, k1.position, k2.position);
		ret = fea_gradient_boost(p, g1, ret);
	}

	return ret;
}

// Given the provided knots and gradients, returns the interpolated value
// at the given 1d coord.
//
// Applies the knots' relative or absolute values,
// the gradients' offset and multiplier, etc.
//
// Expects the gradients' array size to be knot_size - 1.
//
// Return color space : okhcl
color fea_lab_interpolate(float in_coord,
		fea_knot_info knots[], int in_knot_size,
		fea_gradient_info gradients[]) {
	int knot_size = min(arraylength(knots), in_knot_size);
	if (knot_size <= 0) {
		return color(0);
	}

	if (knot_size == 1) {
		return knots[0].lab;
	}

	if (in_coord <= knots[0].position) {
		return knots[0].lab;
	}

	int last_idx = knot_size - 1;
	if (in_coord >= knots[last_idx].position) {
		return knots[last_idx].lab;
	}

	// Find the surrounding knots and gradients for later interpolation.
	fea_knot_info knot0;
	fea_gradient_info gradient0;
	fea_knot_info knot1;
	fea_gradient_info gradient1;
	fea_knot_info knot2;
	fea_gradient_info gradient2;
	fea_knot_info knot3;

	{
		float eps = 0.5;

		int i;
		for (i = 0; i < last_idx; ++i) {
			if (in_coord >= knots[i].position && in_coord < knots[i + 1].position) {
				break;
			}
		}

		int i0 = max(0, i - 1);
		int i1 = i;
		int i2 = i + 1;
		int i3 = min(last_idx, i + 2);

		knot0 = knots[i0];
		knot1 = knots[i1];
		knot2 = knots[i2];
		knot3 = knots[i3];

		// Fudge the before / after positions if we are only interpolating
		// 2 (or 3) points.
		if (i0 == i1) {
			knot0.position -= eps;
		}
		if (i2 == i3) {
			knot3.position += eps;
		}

		gradient0 = gradients[i0];
		gradient1 = gradients[i1];
		gradient2 = gradients[i2];
	}

	// Convert to percentage ramp between surrounding knots.
	float local_coord = fea_per(in_coord, knot1.position, knot2.position);

	if (gradient1.interp_mode == 0) {
		// linear
		return fea_linear_gradient(local_coord, knot1, gradient1, knot2);
	}

	if (gradient1.interp_mode == 1) {
		// staircase
		return fea_staircase_gradient(local_coord, knot1, gradient1, knot2);
	}

	if (gradient1.interp_mode == 2) {
		// catmull-rom
		return fea_catmull_gradient(local_coord, knot0, gradient0, knot1, gradient1, knot2, gradient2, knot3);
	}

	return 0;
}

// 		"Simple Hue:0"
// 		"|Heat Map:1"
// 		"|Bright Burn:2"
// 		"|Dark Burn:9"
// 		"|Complements:3"
// 		"|Analogous:4"
// 		"|Split-Complementary:5"
// 		"|Triad:6"
// 		"|Tetradic:7"
// 		"|Square:8"

shader ColorLab
[[
	string help  =
		"<h3>Color Lab</h3>"
		"A color gradient playground, in Oklab color space."
		,
	string label = "Color Lab"
]]
(
	float In = 0
	[[
		string label = "In (float)",
		string help = "Input grayscale map, expects float.",
		// string widget = "null",
	]],

	color in_base_color = 0
	[[
		string label = "Base Color",
		string help = "When using Knot 1 in relative mode, this input map is used as the relative-to color.",
		// string widget = "null",
	]],

	// FEA_TITLE(142, "Preprocess"),

	int in_clamp = 0
	[[
		string label = "Clamp Input",
		string help = "Clamps the input between expected [0, 1].",
		int connectable = 0,
		string widget = "checkBox",
	]],

	int in_invert = 0
	[[
		string label = "Invert Input",
		string help = "Flips the input values, 1 becomes 0, 0 becomes 1.",
		int connectable = 0,
		string widget = "checkBox",
	]],

	int in_debug_out_of_range = 0
	[[
		string label = "Debug Out-of-range Colors",
		string help = "",
		int connectable = 0,
		string widget = "checkBox",
	]],

	FEA_SPACER(0),
	FEA_TITLE(0, "Knot 1 (Base Knot)"),

	int in_k1_mode = 1
	[[
		string widget = "mapper",
		string label = "K1 - Mode",
		string options =
			"Absolute (Color):0"
			"|Relative (Base Color Map + HCL Offset):1"
			,
		string help = "Relative Mode : Unlike other knots, when the base knot is in relative mode, it uses the Base Color map input as a source.<br>"
				"Absolute Mode : The knot use a specific color.",
		int connectable = 0,
	]],

	color in_k1_color = 0
	[[
		string label = "K1 - Color",
		string help = "The absolute color value used in absolute mode.",
	]],

	vector in_k1_hcl_offset = vector(0, 0.0, 0.0)
	[[
		string label = "K1 - HCL Offset",
		string help = "The offset values added to the 'Base Color' map.<br>"
				"Hue (degrees) : [0, 360]<br>"
				"Chroma (percentage) : [0, 1]<br>"
				"Lightness (percentage) : [0, 1]",
	]],

	FEA_SPACER(1),
	FEA_TITLE(1, "Gradient 1"),

	int in_g1_interp_mode = 0
	[[
		string widget = "mapper",
		string label = "G1 - Interpolation",
		string options =
			fea_gradient_interpolation_opts,
		string help = "The gradient interpolation mode.",
		int connectable = 0,
	]],

	int in_g1_staircase_steps = 1
	[[
		string label = "G1 - Staircase Steps",
		string help = "Amount of steps when using staircase interpolation. 1 step is equivalent to 'Constant' interpolation.",
		int min = 1,
		int connectable = 0,
	]],

	// float in_g1_staircase_border_width = 0.1
	// [[
	// 	string label = "G1 - Staircase Border Width",
	// 	string help = "The width of the border used to apply Chroma and Lightness boost.",
	// 	int connectable = 0,
	// ]],

	float in_g1_chroma_boost = 0.0
	[[
		string label = "G1 - Chroma Boost",
		string help = "Adds (or substracts) from chroma during interpolation.",
		float min = -1.0,
		float max = 1.0,
	]],

	float in_g1_lightness_boost = 0.0
	[[
		string label = "G1 - Lightness Boost",
		string help = "Adds (or substracts) from lightness during interpolation.",
		float min = -1.0,
		float max = 1.0,
	]],


	FEA_SPACER(42),
	FEA_TITLE(42, "Knot 4 (Last Knot)"),
	int in_k4_mode = 0
	[[
		string widget = "mapper",
		string label = "K4 - Mode",
		string options =
			"Absolute (Color):0"
			"|Relative (HCL Offset):1"
			,
		string help = "Relative Mode : In relative mode, the knot acts as an offset to the previous knot.<br>"
				"Absolute Mode : The knot use a specific color, ignoring the previous knot.",
		int connectable = 0,
	]],

	color in_k4_color = 1
	[[
		string label = "K4 - Color",
		string help = "The absolute color value used in absolute mode..",
	]],

	vector in_k4_hcl_offset = 0
	[[
		string label = "K4 - HCL Offset",
		string help = "The offset values added to the previous knot.<br>"
				"Note : The Hue value is in degrees [0, 360], "
				"whereas the Chroma and Lightness values are in percentage [0, 1].",
	]],

	// float in_k4_position = 1.0
	// [[
	// 	string label = "K4 - Position",
	// 	string help = "The 'x' position of this knot on the gradient.<br>"
	// 			"Note : The gradients always refer to their surrounding knots, which may lead to inconsistent UI if knot order isn't respected.",
	// 	float min = 0.0,
	// 	float max = 1.0,
	// ]],

	output color Out = 0
)
{
	// The grayscale input.
	float val = In;
	if (in_clamp) {
		val = clamp(val, 0.0, 1.0);
	}

	if (in_invert) {
		val = 1.0 - val;
	}

	// Prepare the datastructures, knots and gradients.
	fea_array_fea_knot_info4 knots;
	fea_array_fea_gradient_info3 gradients;
	fea_init(knots);
	fea_init(gradients);

	// Knot 1 is special snowflake.
	{
		fea_knot_info knot;
		knot.position = 0;

		if (in_k1_mode == 0) {
			// absolute
			knot.lab = fea_transformc("oklab", in_k1_color);
		} else {
			// relative, make absolute using base color map.
			color col = fea_transformc("okhcl", in_base_color);
			col = color(
				fea_deg_to_per(in_k1_hcl_offset[0]) + col[0],
				in_k1_hcl_offset[1] + col[1],
				in_k1_hcl_offset[2] + col[2]
			);
			knot.lab = fea_transformc("okhcl", "oklab", col);
		}

		fea_push_back(knot, knots);
	}


	// Gradient 1
	{
		fea_gradient_info gradient;

		gradient.interp_mode = in_g1_interp_mode;
		gradient.steps = in_g1_staircase_steps;
		gradient.cl_boost = color(
			0,
			in_g1_chroma_boost,
			in_g1_lightness_boost
		);

		fea_push_back(gradient, gradients);
	}

	// TODO : Other knots.

	// Knot 4
	{
		fea_knot_info knot;
		// TODO : expose knot position
		knot.position = 1.0;

		if (in_k4_mode == 0) {
			// color test = transformc("rgb", in_k4_color);
			knot.lab = fea_transformc("oklab", in_k4_color);
		} else {
			// relative, make absolute to previous knot
			fea_knot_info prev_knot = fea_back(knots);

			color col = fea_transformc("oklab", "okhcl", prev_knot.lab);
			col = color(
				fea_deg_to_per(in_k4_hcl_offset[0]) + col[0],
				in_k4_hcl_offset[1] + col[1],
				in_k4_hcl_offset[2] + col[2]
			);
			knot.lab = fea_transformc("okhcl", "oklab", col);
		}

		fea_push_back(knot, knots);
	}

	color result = fea_lab_interpolate(val, knots.data, knots.size, gradients.data);

	Out = fea_transformc("oklab", "rgb", result);
	// Out = clamp(Out, color(0), color(1));

	// Debug out-of-range.
#if 1
	if (in_debug_out_of_range) {
	for (int i = 0; i < 3; ++i) {
		if (Out[i] > 1.0) {
			Out = color(1,0,1);
		}
		if (Out[i] < 0.0) {
			Out = color(0,1,0);
		}
	}
	}
#endif
}