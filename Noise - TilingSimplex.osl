// TilingSimplex Shader
// TilingSimplex by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_tsimplex.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_widget_phase.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_widget_uvw.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_shape.osl"

// TODO : Debug why gradient is so far out-of-range of expected magnitude
// of 2 (for -1,1) and 1 (for 0,1).

// TODO : move back to fea_tsimplex.osl
// Unsigned overload, return [0, 1].
fea_tsimplex_ret fea_utsimplex(point coord, vector period, float phase) {
	fea_tsimplex_ret ret = fea_tsimplex(coord, period, phase);
	ret.value = ret.value * 0.5 + 0.5;
	ret.gradient *= 0.5;
	ret.dg *= 0.5;
	ret.dg2 *= 0.5;
	return ret;
}


// Tiling simplex FBM.
fea_tsimplex_ret fea_tsimplex_fbm(point coord, int num_octaves, float lacunarity, vector period, float phase) {
	fea_tsimplex_ret ret;
	fea_init(ret);

	fea_tsimplex_ret fbm_callback(float freq) {
		return fea_tsimplex(coord * freq + freq * 0.1, period * freq, phase);
	}

	fea_fractalize(num_octaves, lacunarity, fbm_callback, ret);
	return ret;
}

// Unsigned tiling simplex FBM.
fea_tsimplex_ret fea_utsimplex_fbm(point coord, int num_octaves, float lacunarity, vector period, float phase) {
	fea_tsimplex_ret ret;
	fea_init(ret);

	fea_tsimplex_ret fbm_callback(float freq) {
		return fea_tsimplex(coord * freq + freq * 0.1, period * freq, phase);
	}

	fea_fractalize(num_octaves, lacunarity, fbm_callback, ret);

	ret.value = ret.value * 0.5 + 0.5;
	// ret.gradient *= 0.5;
	// ret.dg *= 0.5;
	// ret.dg2 *= 0.5;
	return ret;
}

// Compute surface normal using gradient, in tangent space.
// The output is normalized as a typical color normal map would be.
// Surface gradient [Mik10].
// Derivative normal [Mik20]
vector fea_tsimplex_normal(string input_space, vector scale, vector gradient) {
	vector up = fea_transform("world", "tangent", N);

	vector grad = gradient * scale;
	grad = fea_transform(input_space, "tangent", grad);
	vector surf_grad = grad - up * dot(grad, up);
	return normalize(up + surf_grad);
}

// Overload for fea_tsimplex_ret.
vector fea_tsimplex_normal(string input_space, vector scale, fea_tsimplex_ret ret) {
	return fea_tsimplex_normal(input_space, scale, ret.gradient);
}


// The functions below in this "Common" tab are hereby placed in
// the public domain. They may be used freely without restrictions.
// To provide legal grounds for the public domain status, I hereby
// certify that I am the original author of these. The weird name
// "ptlined" is a nod to historic Renderman SL, but I wrote this code.
// The name "aastep" is not really a nod to OSL, though.
// I doubt that Larry Gritz got the rather obvious name from me,
// but I was first, and I have a published book chapter from 2012
// to prove it, and an (unpublished) RSL shader from 2006. :)

// Compute the shortest distance from p to a line segment from p1 to p2.
float ptlined(vector p1, vector p2, vector p) {
  vector p1p2 = p2 - p1;
  vector v = normalize(p1p2);
  vector s = p - p1;
  float t = dot(v, s);
  if (t<0.0) return length(s);
  if (t>length(p1p2)) return length(p - p2);
  return length(s - t*v);
}

// Auto-antialiased step function
float maastep(float threshold, float value) {
//   float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));
  float afwidth = 0.005;
  return smoothstep(threshold-afwidth, threshold+afwidth, value);
}

// Anti-aliased implicit line around v == t, in the spirit of
// aastep(), with line width w specified in fragment space (pixels)
float maaline(float t, float v, float w) {
//   float fw = 0.7 * length(vector(Dx(v), Dy(v), 0));
  float fw = 0.002;
  return smoothstep(t-0.5*w*fw-fw, t-0.5*w*fw+fw, v)
	- smoothstep(t+0.5*w*fw-fw, t+0.5*w*fw+fw, v);
}

// "Paint" a regular grid of implicit arrows to visualize a vector field.
// The arrows are antialiased. (Jaggies are extra ugly in animated line art.)
// The value for g should be constant over each grid cell, or you will
// get strange results (bendy, wiggly or broken-up arrows).
float vectorfield(vector g, vector st, float gscale, float linewidth) {
  // pm.xy are coords [-0.5,0.5] relative to nearest arrow origin
  vector pm = fract(st*gscale+0.5)-0.5;
  float linedist = ptlined(-g*0.5, g*0.5, pm); // distance to arrow "body"
  float line = 1.0 - maastep(linewidth*0.5, linedist);
  // The arrowhead is an implicit triangle defined by three linear equations
  float arrowsize = linewidth*0.7; // arrowhead size, eyeballed for nice look
  vector a_vec = pm - g*0.5; // current coords relative to the pointy end
  vector g_ = vector(-g.y, g.x, 0); // vector orthogonal to g
  float arrow1 = dot(a_vec, -normalize(g)); // Distance to arrowhead base
  float arrow2 = dot(a_vec, normalize( g + 1.5*g_ )); // to arrowhead right edge
  float arrow3 = dot(a_vec, normalize( g - 1.5*g_ )); // to arrowhead left edge
  float arrowd = max(max(arrow1, arrow2), arrow3); // if<arrowsize: inside triangle
  float arrowhead = 1.0 - maastep(arrowsize, arrowd);
  // Mask out cell borders where discontinuities cause errors in aastep()
  vector bordermask = step(-0.45,pm)-step(0.45,pm);
  float mask = bordermask.x * bordermask.y;
  return max(line, arrowhead)*mask;
}



shader TilingSimplex
[[
	string label = "Noise - Tiling Simplex",
	string help	=
		"<h3>Tiling Simplex</h3>"
		"A spacially and temporally tiling simplex noise.<br>"
		"Port of Stefan Gustavson's and Ian McEwan's GLSL implementation."
		,
]]
(
	int in_fbm_octaves = 3
	[[
		string label = "Octaves",
		string help = "How many octaves used for the fractal brownian motion (clouds).",
		int min = 1,
		int max = 6,
		int connectable = 0,
		// string packName = "Octaves / Lacunarity",
	]],

	float in_lacunarity = 1.8
	[[
		string label = "Lacunarity",
		string help = "The frequency growth factor used by the fractalization.",
		float min = 0.01,
		int connectable = 0,
		// string packName = "Octaves / Lacunarity",
	]],

	vector in_tiling = 0.0
	[[
		string label = "Tile Size",
		string help = "These are the x, y, z periods, used to tile the noise. [0, 0, 0] disables tiling (infinite noise).",
		float max = 289.0,
		int connectable = 0,
	]],

	FEA_SPACER(0),

	float in_low_clamp = 0.0
	[[
		string label = "Low Value",
		string help = "The minimum value of the noise. Hard clamped.",
		float min = 0.0,
		float max = 1.0,
		// string packName = "High / Low Clamp",
	]],

	float in_high_clamp = 1.0
	[[
		string label = "High Value",
		string help = "The maximum value of the noise. Hard clamped.",
		float min = 0.0,
		float max = 1.0,
		// string packName = "High / Low Clamp",
	]],

	color in_low_color = 0
	[[
		string label = "Low Color",
		string help = "The dark color (noise == 0).",
	]],

	color in_high_color = 1
	[[
		string label = "High Color",
		string help = "The light color (noise == 1).",
	]],

	FEA_WGT_PHASE_INPUTS,
	FEA_WGT_UVW_INPUTS,

	output color out_col = 0
	[[
		string label = "Out (color)"
	]],
	output float out_float = 0
	[[
		string label = "Out (float)"
	]],
	output color out_normal = 0
	[[
		string label = "Normal (color)"
	]],
	output vector out_gradient = 0
	[[
		string label = "Gradient (vector)"
	]],
	output vector out_second_deriv = 0
	[[
		string label = "2nd Derivative (vector)"
	]],
	output vector out_second_deriv2 = 0
	[[
		string label = "2nd Derivative 2 (vector)"
	]]
)
{
	fea_wgt_uvw_ret uvw_data = FEA_WGT_GET_UVW;
	point coord = uvw_data.coord;
	float phase = FEA_WGT_GET_PHASE;

	fea_tsimplex_ret ret = fea_utsimplex_fbm(coord, in_fbm_octaves, in_lacunarity, in_tiling, phase);
	ret.value = fea_lerp(ret.value, 0.0, 1.0, in_low_clamp, in_high_clamp);

	out_col = mix(in_low_color, in_high_color, ret.value);
	out_float = ret.value;
	out_gradient = ret.gradient;
	out_second_deriv = ret.dg;
	out_second_deriv2 = ret.dg2;

	// Compute normal using surface gradient method.
	vector n = fea_tsimplex_normal(uvw_data.coord_space, uvw_data.scale,
			ret.gradient);
	// Normalize to expected rgb color map [-1,1] -> [0,1].
	out_normal = n * 0.5 + 0.5;

#if 0
	// float mag = length(ret.gradient * uvw_data.scale);
	// if (mag >= 1.0) {
	// 	out_col = fea_red;
	// }
	// if (mag >= 2.0) {
	// 	out_col = fea_green;
	// }
	// if (mag >= 4.0) {
	// 	out_col = fea_blue;
	// }
	// if (mag >= 5.0) {
	// 	out_col = color(1);
	// }
	// if (mag >= 6.9) {
	// 	out_col = color(0);
	// }
#endif

#if 0
    // Make sure to supply the matching "gscale" here
	vector test = vector(uvw_data.coord[0], uvw_data.coord[1], 0);
	// vector test = uvw_data.coord / uvw_data.scale;
	test = fract(test);
	// test *= uvw_data.scale;
    float arrows = vectorfield(test,
			uvw_data.coord,
			uvw_data.scale[0], 0.1);

    // Draw a few isoline contours as well, to more
    // clearly show the structure of the noise pattern.
    float isolines;
    isolines =  maaline(0.2, ret.value, 2.0);
    isolines += maaline(0.4, ret.value, 2.0);
    isolines += maaline(0.6, ret.value, 2.0);
    isolines += maaline(0.8, ret.value, 2.0);

	color mixcolor = color(ret.value);
	color linecolor = color(0.0,1.0,0.0);
	color arrowcolor = color(1.0,1.0,0.0);
    mixcolor = mix(mixcolor, linecolor, isolines*0.5);
	mixcolor = mix(mixcolor, arrowcolor, arrows);
	out_col = mixcolor;
#endif

	point grid_coord = fea_grid_coord(coord, uvw_data.coord_space, 0.5);
	fea_shape_style style;
	fea_init(style);

	style.shape_feather_interp = 0;
	style.shape_feather = 1.0;
	style.border_style = 1;
	style.border_size = in_lacunarity;
	style.border_feather_interp = 0;
	style.border_feather = 0;


	fea_shape s = fea_sphere(grid_coord, 1.0, style);
	out_col = mix(color(0), fea_red, s.shape_mask);
	out_col = mix(out_col, color(1), s.border_mask);



// 	// Define a function where 0 == surface, -n inside, +n outside.
// 	float func(vector p) {
// 		// return dot(p, p) - pow(1.0, 2.0);
// 		float r = length(p);
// 		float a = atan2(p[1],p[0]);
// 		return r - 1.0 + 0.5*sin(3.0*a+2.0*r*r);
// 	}

// 	float eps = length(filterwidth(coord));
// 	eps = 0.0001;
// 	// eps = 0.05;
// #if 0
// 	float dist = abs(func(grid_coord));
// #else
// 	float dist = fea_distance_to_func_3d(coord, eps, func);
// #endif

// 	dist = abs(dist);
// 	eps = 0.01;
// 	out_col = fea_near(dist, 0, 0.01);
// 	out_col = smoothstep( 1.0*eps, 2.0*eps, dist );
// 	// out_col = aastep(0.1, dist);
// 	// out_col = abs(dist);
}
