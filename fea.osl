// fea osl libraries by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt
#define fea_osl 1

#define FEA_RPACK_W 50
#define FEA_SPACER(n) int __spacer##n = 0 [[string widget = "checkBox", int connectable = 0, int widgetWidth = 1]],
#define FEA_FLT_MAX 3.402823e+38

/**
 * Conversions
 */

// Converts a precentage to radian.
// Expects percent 0.0 to 1.0.
float fea_per_to_rad(float percent) {
	return percent * M_2PI;
}

// Converts a radian to percentage.
// Returns percent 0.0 to 1.0.
float fea_rad_to_per(float rad) {
	return rad * 0.15915494309189498;
}

// Given a radian angle, returns a 2d vector pointing
// in that direction.
vector fea_angle_to_vec(float rad) {
	return vector(cos(rad), sin(rad), 0);
}


/**
 * Convolutions
 */

// Sobel operator convolution.
// Pass in a 3x3 matrix of data to convolve.
// x
// |-1| 0| 1|
// |-2| 0| 2|
// |-1| 0| 1|
// y
// |-1|-2|-1|
// | 0| 0| 0|
// | 1| 2| 1|
vector fea_sobel_gradient(matrix m) {
	float x = -m[0][0] + m[0][2] - 2 * m[1][0] + 2 * m[1][2]
			- m[2][0] + m[2][2];

	float y = -m[0][0] - 2 * m[0][1] - m[0][2]
			+ m[2][0] + 2 * m[2][1] + m[2][2];

	return vector(x, y, 0);
}

// Sharpen convolution.
// Pass in a 3x3 matrix of data to convolve.
float fea_sharpen(matrix m) {
	return -m[0][1] - m[1][0] + 5 * m[1][1] - m[1][2] - m[2][1];
}

// Blur convolution.
// Pass in a 3x3 matrix of data to convolve.
float fea_blur(matrix m) {
	return 0.0625 * (m[0][0] + m[0][2] + m[2][0] + m[2][2])
			+ 0.125 * (m[0][1] + m[1][0] + m[1][2] + m[2][1])
			+ 0.25 * m[1][1];
}

// Emboss convolution.
// Pass in a 3x3 matrix of data to convolve.
float fea_emboss(matrix m) {
	return -2 * m[0][0] - m[0][1] - m[1][0] + m[1][1] + m[1][2] + m[2][1] + 2 * m[2][2];
}

// Outline convolution.
// Pass in a 3x3 matrix of data to convolve.
float fea_outline(matrix m) {
	return -m[0][0] - m[0][1] - m[0][2] - m[1][0] + 8 * m[1][1] - m[1][2] - m[2][0] - m[2][1] - m[2][2];
}


#define fea_imp_xe(eps) vector(eps, 0.0, 0.0)
#define fea_imp_ye(eps) vector(0.0, eps, 0.0)
#define fea_imp_ze(eps) vector(0.0, 0.0, eps)

// A simpler less expensive numerical gradient.
// Basically Robert's Cross.
//
// Expected func signature :
// float f(vector);
#define fea_gradient_2d(x, eps, func) \
	vector( \
		func(x + fea_imp_xe(eps)) - func(x - fea_imp_xe(eps)), \
		func(x + fea_imp_ye(eps)) - func(x - fea_imp_ye(eps)), \
		0.0 \
	) / (2.0 * eps)

// A simpler less expensive numerical 3d gradient.
// Basically Robert's Cross expanded in z.
//
// Expected func signature :
// float f(vector);
#define fea_gradient_3d(x, eps, func) \
	vector( \
		func(x + fea_imp_xe(eps)) - func(x - fea_imp_xe(eps)), \
		func(x + fea_imp_ye(eps)) - func(x - fea_imp_ye(eps)), \
		func(x + fea_imp_ze(eps)) - func(x - fea_imp_ze(eps)) \
	) / (2.0 * eps)

// Computes the distance from point x to your function.
// That is : abs(f(x)) / abs(gradient(f(x)))
// https://iquilezles.org/articles/distance/
//
// Expected func signature :
// float f(vector);
#define fea_distance_field_2d(x, eps, func) \
	abs(func(x)) / length(fea_gradient_2d(x, eps, func))

// Computes the distance from point x to your function.
// That is : abs(f(x)) / abs(gradient(f(x)))
// https://iquilezles.org/articles/distance/
//
// Expected func signature :
// float f(vector);
#define fea_distance_field_3d(x, eps, func) \
	abs(func(x)) / length(fea_gradient_3d(x, eps, func))

/**
 * Interpolation
 */

// Given a value val, returns the closest multiple.
float fea_closest_multiple(float val, float multiple) {
	if (multiple == 0.0) {
		return 0.0;
	}
	return floor(val / multiple) * multiple;
}

// Floor up to decimal.
float fea_floor_to(float val, float decimal_mul) {
	return floor(val * decimal_mul) / decimal_mul;
}
vector fea_floor_to(vector val, float decimal_mul) {
	return vector (
			floor(val[0] * decimal_mul) / decimal_mul,
			floor(val[1] * decimal_mul) / decimal_mul,
			floor(val[2] * decimal_mul) / decimal_mul
	);
}

// Given the 3 colors and a precentage,
// mix between them (1/3 per color).
color fea_mix(color c1, color c2, color c3, float p) {
	float p1 = clamp(p * 2 - 1, 0, 1);
	color temp = mix(c2, c3, p1);

	float p2 = clamp(p * 2, 0, 1);
	return mix(c1, temp, p2);
}

// Given the 4 colors and a precentage,
// mix between them (1/4 per color).
color fea_mix(color c1, color c2, color c3, color c4, float p) {
	float p1 = clamp(p * 3 - 2, 0, 1);
	color temp1 = mix(c3, c4, p1);

	float p2 = clamp(p * 3 - 1, 0, 1);
	color temp2 = mix(c2, temp1, p2);

	float p3 = clamp(p * 3, 0, 1);
	return mix(c1, temp2, p3);
}

// Play with k,
// https://www.desmos.com/calculator/og836nvwmx
// k > 0, exponential
// k == 0, linear
// k < 0, logarithmic
float fea_interp(float k, float percent) {
	float ret = 0.0;
	float epsilon = 0.0001;
	if (fabs(k) < epsilon) {
		// Actual k = 0 == 0 always. Just do linear interp.
		ret = percent;
	} else {
		ret = (exp(k * percent) - 1.0) / (exp(k) - 1.0);
	}
	return ret;
}

// fea_blend enum ui options.
#define fea_blend_opts \
		"None:0" \
		"|Replace:1" \
		"|Darken:3" \
		"|Multiply:4" \
		"|Color Burn:5" \
		"|Linear Burn:6" \
		/*"|Darker Color:7"*/ \
		"|Lighten:8" \
		"|Screen:9" \
		"|Color Dodge:10" \
		"|Linear Dodge (Add):11" \
		/*"|Lighter Color:12"*/ \
		"|Overlay:13" \
		"|Soft Light:14" \
		"|Hard Light:15" \
		"|Vivid Light:16" \
		"|Linear Light:17" \
		"|Pin Light:18" \
		"|Hard Mix:19" \
		"|Difference:20" \
		"|Exclusion:21" \
		"|Substract:22" \
		"|Divide:23" \
		/*"|Hue:24"*/ \
		/*"|Saturation:25"*/ \
		/*"|Color:26"*/ \
		/*"|Luminosity:27"*/ \
		"|Average:28"

// Blend 2 floats using typical color blend modes.
// 'bot' is base layer, 'top' is top layer.
float fea_blend(int blend_type, float bot, float top) {
	// http://www.simplefilter.de/en/basics/mixmods.html

	float ret = bot;
	if (blend_type == 0) {
		// none
		// ret = bot;
	} else if (blend_type == 1) {
		// replace
		ret = top;
	} else if (blend_type == 3) {
		// darken
		ret = min(bot, top);
	} else if (blend_type == 4) {
		// multiply
		ret = bot * top;
	} else if (blend_type == 5) {
		// color burn
		ret = 1 - (1 - bot) / top;
	} else if (blend_type == 6) {
		// linear burn
		ret = bot + top - 1;
	} else if (blend_type == 7) {
		// todo : darker color
	} else if (blend_type == 8) {
		// lighten
		ret = max(bot, top);
	} else if (blend_type == 9) {
		// screen
		ret = 1 - (1 - bot) * (1 - top);
	} else if (blend_type == 10) {
		// color dodge
		ret = bot / (1 - top);
	} else if (blend_type == 11) {
		// linear dodge (add)
		ret = bot + top;
	} else if (blend_type == 12) {
		// todo : lighter color
	} else if (blend_type == 13) {
		// overlay
		if (bot <= 0.5) {
			ret = 2 * bot * top;
		} else {
			ret = 1 - 2 * (1 - bot) * (1 - top);
		}
	} else if (blend_type == 14) {
		// soft light
		ret = (1 - 2 * top) * pow(bot, 2) + 2 * bot * top;
	} else if (blend_type == 15) {
		// hard light
		if (top <= 0.5) {
			ret = 2 * top * bot;
		} else {
			ret = 1 - 2 * (1 - top) * (1 - bot);
		}
	} else if (blend_type == 16) {
		// vivid light
		if (top <= 0.5) {
			ret = 1 - (1 - bot) / (2 * top);
		} else {
			ret = bot / (2 * (1 - top));
		}
	} else if (blend_type == 17) {
		// linear light
		ret = bot + 2 * top - 1;
	} else if (blend_type == 18) {
		// pin light
		if (bot < 2 * top - 1) {
			ret = 2 * top - 1;
		} else if (bot > 2 * top) {
			ret = 2 * top;
		} else {
			ret = bot;
		}
	} else if (blend_type == 19) {
		// hard mix
		if (top < 1 - bot) {
			ret = 0;
		} else {
			ret = 1;
		}
	} else if (blend_type == 20) {
		// difference
		ret = fabs(top - bot);
	} else if (blend_type == 21) {
		// exclusion
		ret = top + bot - 2 * top * bot;
	} else if (blend_type == 22) {
		// substract
		ret = bot - top;
	} else if (blend_type == 23) {
		// divide
		float t = top == 0.0 ? 0.0000001 : top;
		ret = bot / t;
	} else if (blend_type == 28) {
		// average
		ret = (bot + top) * 0.5;
	}

	return ret;
}

vector fea_blend(int blend_type, vector bot, vector top) {
	return vector(
		fea_blend(blend_type, bot[0], top[0]),
		fea_blend(blend_type, bot[1], top[1]),
		fea_blend(blend_type, bot[2], top[2])
	);
}


float fea_average(color in) {
	return (in[0] + in[1] + in[2]) / 3.0;
}
float fea_average(vector in) {
	return (in[0] + in[1] + in[2]) / 3.0;
}

// Given a grayscale float input, creates "level sets"
// and blends according to step_mode (see fea_blend for blend options).
float fea_fancy_step(int step_mode, int step_amount, float in_val) {
	int int_val = int(in_val * step_amount);
	float val = float(int_val) / float(step_amount);
	return fea_blend(step_mode, in_val, val);
}


/**
 * Math Utils
 */

// Clouds (aka Fractal Brownian Motion).
float fea_fbm(int iterations, vector coord, float phase) {
	float ret = 0.0;

	for (int i = 1; i < iterations + 1; ++i) {
		float size = i / float(iterations);
		ret += noise("usimplex", coord / size, phase + size) * size;
	}

	ret /= float(iterations);
	return ret;
}

// Returns squared magnitude.
float fea_length_squared(vector x) {
	return dot(x, x);
}

// sin from 0 to 1
float fea_usin(float x) {
	return (sin(x) + 1.0) * 0.5;
}
vector fea_usin(vector x) {
	return (sin(x) + 1.0) * 0.5;
}

// cos from 0 to 1
float fea_ucos(float x) {
	return (cos(x) + 1.0) * 0.5;
}
vector fea_ucos(vector x) {
	return (cos(x) + 1.0) * 0.5;
}

/**
 * glsl compatability
 */
vector vec2(float x, float y) {
	return vector(x, y, 0.0);
}

float fract(float in) {
	return in - floor(in);
}
// color fract(color in) {
// 	return in - floor(in);
// }
vector fract(vector in) {
	return in - floor(in);
}

/**
 * Hashes
 */
vector fea_hash1_osl(float seed, vector p) {
	vector q = noise("hash", p, seed);
	q[1] = 0.0;
	q[2] = 0.0;
	return q;
}
vector fea_hash2_osl(float seed, vector p) {
	vector q = noise("hash", p, seed);
	q[2] = 0.0;
	return q;
}
vector fea_hash3_osl(float seed, vector p) {
	return noise("hash", p, seed);
}

vector fea_hash1_iq(float seed, vector p) {
	return vector(fract(sin(p[0] + seed) * 43758.5453), 0.0, 0.0);
}
vector fea_hash2_iq(float seed, vector p) {
	vector q = vector(
		dot(p, vector(127.1, 311.7, 0.0)),
		dot(p, vector(269.5, 183.3, 0.0)),
		0.0
	);
	q[0] += seed;
	q[1] += seed;
	return fract(sin(q) * 43758.5453);
}
vector fea_hash3_iq(float seed, vector p) {
	vector q = vector(
		dot(p, vector(127.1, 311.7, 0.0)),
		dot(p, vector(269.5, 183.3, 0.0)),
		dot(p, vector(419.2, 371.9, 0.0))
	);

	return fract(sin(q + seed) * 43758.5453);
}


/**
 * Algorithms & Typical coding
 */
#define fea_runtime_array(struct_name, type, max_size) \
	struct struct_name { \
		type data[max_size]; \
		int size; \
	}; \
	\
	void fea_erase(output struct_name arr, int i) { \
		if (i < arr.size) { \
			arr.data[i] = arr.data[arr.size - 1]; \
			arr.size -= 1; \
		} \
	}