// // Playground for whatever Shader
// // Playground for whatever by Philippe Groarke
// // Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// // https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_tsimplex.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_widget_phase.osl"
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_widget_uvw.osl"

shader Playground
[[
	string help  =
		"Sandbox"
		,
	string label = "Playground"
]]
(
	FEA_WGT_PHASE_INPUTS,
	FEA_WGT_UVW_INPUTS,

	output vector Out = 0,
	output vector Normal = 0,
	output vector Normal2 = 0,
	output float Displace = 0,
	output vector Tangent = 0
)
{

#if 1
	fea_wgt_uvw_ret uvw_data = FEA_WGT_GET_UVW;
	float phase = FEA_WGT_GET_PHASE;

	point coord = uvw_data.coord;
	fea_tsimplex_ret ret = fea_utsimplex_fbm(coord, 20, 1.7, vector(0), phase);
	Out = ret.value;

	string working_space = "tangent";
	vector up = fea_transform("world", working_space, N);
	vector grad = fea_transform(uvw_data.coord_space, working_space, ret.gradient);

	{
		// Surface gradient [Mik10].
		grad = normalize(grad);
		vector surf_grad = grad - up * dot(grad, up);

		// Derivative normal [Mik20]
		vector n = normalize(up + 0.25 * surf_grad);
		n = fea_transform(working_space, "tangent", n);
 		n = n * 0.5 + 0.5;
		Normal2 = n;
	}

	Displace = ret.value * 1.0;
	// {
	// 	vector fwd = normalize(grad);
	// 	vector side = normalize(cross(fwd, up));
	// 	vector n = normalize(cross(side, fwd));
	// 	n = fea_transform(working_space, "tangent", n);

	// 	// Rectify for expected texture range [0,1];
 	// 	n = n * 0.5 + 0.5;
	// 	Normal = n;
	// 	// return;
	// }

#else
// 	point coord = in_uvw / in_uvw_scale;
// 	// Curl Noise test
// 	// float epsilon = 0.0001;
// 	// point coord = in_uvw / in_uv_scale;

// 	// vector x_move = vector(epsilon, 0.0, 0.0);
// 	// vector y_move = vector(0.0, epsilon, 0.0);

// 	// float x1 = noise("usimplex", coord + x_move, in_phase);
// 	// float x2 = noise("usimplex", coord - x_move, in_phase);
// 	// float x_avg = (x1 - x2) / (2.0 * epsilon);

// 	// float y1 = noise("usimplex", coord + y_move, in_phase);
// 	// float y2 = noise("usimplex", coord - y_move, in_phase);
// 	// float y_avg = (y1 - y2) / (2.0 * epsilon);

// 	// // Rotate the uvs.

// 	// // Out = coord + vector(y_avg, -x_avg, 0.0);
// 	// // Out = coord + vector(y_avg + in_phase, -(x_avg + in_phase), 0.0);

// 	// // Our func.
// 	// // float test2 = (
// 	// // 	float r = length(x);
// 	// // 	float a = atan2(x[1], x[0]);
// 	// // 	float test1 = r - 1.0 + 0.5 * sin(3.0 * a + 2.0 * r * r);
// 	// // 	return test1;
// 	// // );


// 	// iq distance field test
// 	float f(vector x) {
// 		float r = length(x);
// 		float a = atan2(x[1], x[0]);
// 		float ret = r - 1.0 + 0.5 * sin(3.0 * a + 2.0 * r * r);
// 		return ret;
// 	}

// 	// mag(f(x)) / mag(grad(f(x))) == abs(f(x)) / mag(grad(f(x)))
// 	float test1 = fea_distance_field_2d(coord * 0.1, 0.1, f);

// 	// Thresholding the function.
// 	float eps = 0.01;
// 	test1 = smoothstep(eps, eps * 1.5, test1);
// 	Out = test1;

#endif
}