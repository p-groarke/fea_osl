// Organic Noise Shader - Caustics, bubbly, and weird noises.
// Organic Noise by Philippe Groarke
// Modified: 2022-07-02
// Copyright 2022 Autodesk Inc, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#define noise_t int
#define STRENGTH_WIDTH 50
#define SPACER(n) int __spacer##n = 0 [[string widget = "checkBox", int connectable = 0, int widgetWidth = 1]],

#if 0
// Returns a 2x2 matrix of noise values starting
// at center coords x,y.
matrix noise_2x2(noise_t noise_type, vector coord, float phase, vector xmove, vector ymove) {
	matrix ret = 0;

	// middlecenter
	{
		point p = coord;
		ret[1][1] = custom_noise(noise_type, p, phase);
	}
	// middleright
	{
		point p = coord + xmove;
		ret[1][2] = custom_noise(noise_type, p, phase);
	}
	// bottomcenter
	{
		point p = coord - ymove;
		ret[2][1] = custom_noise(noise_type, p, phase);
	}
	// bottomright
	{
		point p = coord + xmove - ymove;
		ret[2][2] = custom_noise(noise_type, p, phase);
	}

	return ret;
}

// Robert's cross convolution.
// Very approximate gradient, but much faster.
// x
// | 1| 0|
// | 0|-1|
// y
// | 0| 1|
// |-1| 0|
vector roberts_gradient(matrix m) {
	float x = m[1][1] - m[2][2];
	float y = m[1][2] - m[2][1];
	return vector(x, y, 0);
}
#endif

// Simplex:0
// Fractal:1
// Fractal Lines:2
float custom_noise(noise_t noise_type, vector coord, float phase) {
	// Minimize calls to noise.
	float ret = noise("simplex", coord, phase);

	if (noise_type == 0) {
		// simplex
		ret = (ret + 1) * 0.5;
	} else if (noise_type == 1) {
		// fractal
		ret = fabs(ret);
	} else if (noise_type == 2) {
		// fractal lines
		ret = 1 - fabs(ret);
		if (ret <= 0.99) {
			ret = 0;
		}
	}
	return ret;
}

// Returns a 3x3 matrix of noise values around
// center coords x,y.
matrix noise_3x3(noise_t noise_type, vector coord, float phase, vector xmove, vector ymove) {
	matrix ret = 0;
	// vector coord = vector(c[0], c[1], 0);

	// topleft
	{
		point p = coord - xmove + ymove;
		ret[0][0] = custom_noise(noise_type, p, phase);
	}
	// topcenter
	{
		point p = coord + ymove;
		ret[0][1] = custom_noise(noise_type, p, phase);
	}
	// topright
	{
		point p = coord + xmove + ymove;
		ret[0][2] = custom_noise(noise_type, p, phase);
	}
	// middleleft
	{
		point p = coord - xmove;
		ret[1][0] = custom_noise(noise_type, p, phase);
	}
	// middlecenter
	{
		point p = coord;
		ret[1][1] = custom_noise(noise_type, p, phase);
	}
	// middleright
	{
		point p = coord + xmove;
		ret[1][2] = custom_noise(noise_type, p, phase);
	}
	// bottomleft
	{
		point p = coord - xmove - ymove;
		ret[2][0] = custom_noise(noise_type, p, phase);
	}
	// bottomcenter
	{
		point p = coord - ymove;
		ret[2][1] = custom_noise(noise_type, p, phase);
	}
	// bottomright
	{
		point p = coord + xmove - ymove;
		ret[2][2] = custom_noise(noise_type, p, phase);
	}

	return ret;
}

// Sobel operator convolution.
// Pass in a 3x3 matrix of data to convolve.
// x
// |-1| 0| 1|
// |-2| 0| 2|
// |-1| 0| 1|
// y
// |-1|-2|-1|
// | 0| 0| 0|
// | 1| 2| 1|
vector fea_sobel_gradient(matrix m) {
	float x = -m[0][0] + m[0][2] - 2 * m[1][0] + 2 * m[1][2]
			- m[2][0] + m[2][2];

	float y = -m[0][0] - 2 * m[0][1] - m[0][2]
			+ m[2][0] + 2 * m[2][1] + m[2][2];

	return vector(x, y, 0);
}

float flatten_top(float mag, float thresh) {
	return mag < thresh ? thresh : mag;
}

float emphasize_top(float mag, float thresh) {
	// Also flip the threshold for UI purposes.
	return mag > 1 - thresh ? 1 - thresh : mag;
}

// Play with k,
// https://www.desmos.com/calculator/og836nvwmx
float fea_interp(float k, float percent) {
	float ret = 0.0;
	float epsilon = 0.0001;
	if (fabs(k) < epsilon) {
		// Actual k = 0 == 0 always. Just do linear interp.
		ret = percent;
	} else {
		ret = (exp(k * percent) - 1.0) / (exp(k) - 1.0);
	}
	return ret;
}

// Blend 2 floats using typical color blend modes.
// 'bot' is base layer, 'top' is top layer.

// None (returns a):0
// Replace:1
// Average:2
// Add:3
// Substract:4
// Multiply:5
// Divide:6
// Lighten:7
// Darken:8
// Overlay:9
// Screen:10
// Difference:11
// Soft Light:12
float fea_blend(int blend_type, float bot, float top) {
	float ret = 0;
	if (blend_type == 0) {
		// none
		ret = bot;
	} else if (blend_type == 1) {
		// replace
		ret = top;
	} else if (blend_type == 2) {
		// average
		ret = (bot + top) * 0.5;
	} else if (blend_type == 3) {
		// add
		ret = bot + top;
	} else if (blend_type == 4) {
		// substract
		ret = bot - top;
	} else if (blend_type == 5) {
		// multiply
		ret = bot * top;
	} else if (blend_type == 6) {
		// divide
		float t = top == 0.0 ? 0.0000001 : top;
		ret = bot / t;
	} else if (blend_type == 7) {
		// lighten
		ret = max(bot, top);
	} else if (blend_type == 8) {
		// darken
		ret = min(bot, top);
	} else if (blend_type == 9) {
		// overlay
		if (bot <= 0.5) {
			ret = 2 * bot * top;
		} else {
			ret = 1 - 2 * (1 - bot) * (1 - top);
		}
	} else if (blend_type == 10) {
		// screen
		ret = 1 - (1 - bot) * (1 - top);
	} else if (blend_type == 11) {
		// difference
		ret = fabs(bot - top);
	} else if (blend_type == 12) {
		// soft light
		ret = (1 - 2 * top) * pow(bot, 2) + 2 * bot * top;
	}

	return ret;
}

vector fea_blend(int blend_type, vector bot, vector top) {
	return vector(
		fea_blend(blend_type, bot[0], top[0]),
		fea_blend(blend_type, bot[1], top[1]),
		fea_blend(blend_type, bot[2], top[2])
	);
}

shader OrganicNoise
[[
	string help  =
		"<h3>Organic Noise</h3>"
		"Modulates and filters OSL noises to produce organic looking noises. Garden variety of caustic, fleshy and weird noises."
		,
	string label = "Organic Noise"
]]
(
	int noise_type = 0
	[[
		string widget = "mapper",
		string label = "Noise Type",
		string options =
			"Simplex:0"
			"|Fractal:1"
			"|Fractal Lines:2",
		string help = "The source noise type. 'Fractal lines' doesn't play well with most options, but is there because why not.",
		int connectable = 0,
	]],

	int camo_mode = 0
	[[
		string widget = "mapper",
		string label = "Camo",
		string options =
			"None:0"
			"|Overlay:9"
			"|Replace:1"
			"|Screen:10"
			"|Average:2"
			"|Lighten:7"
			"|Darken:8"
			"|Difference:11"
			"|Soft Light:12"
			"|Add:3"
			"|Substract:4"
			"|Multiply:5"
			"|Divide:6"
			,
		string help = "Gives a 'camouflage' look to the noise.",
		int connectable = 0,
		string packName = "Camo / Seed",
	]],

	float camo_seed = 0
	[[
		string units = "degrees",
		string label = "Camo Seed",
		string help = "An angle used to tweak 'camo', 0 to 360 degrees.",
		float sensitivity = 1,
		int digits = 0,
		float min = 0,
		float max = 360,
		int connectable = 0,
		string packName = "Camo / Seed",
		int widgetWidth = STRENGTH_WIDTH,
	]],

	int bubbles_mode = 0
	[[
		string widget = "mapper",
		string label = "Bubbles",
		string options =
			"None:0"
			"|Overlay:9"
			"|Replace:1"
			"|Screen:10"
			"|Average:2"
			"|Lighten:7"
			"|Darken:8"
			"|Difference:11"
			"|Soft Light:12"
			"|Add:3"
			"|Substract:4"
			"|Multiply:5"
			"|Divide:6"
			,
		string help = "Gives a 'bubbly' thicker look to the noise.",
		int connectable = 0,
		string packName = "Bubbles / Strength",
	]],

	float bubbles_strength = 1.0
	[[
		string label = "Bubbles Strength",
		string help = "Affects bubbles strength.",
		float min = 0,
		float max = 1,
		int connectable = 0,
		string packName = "Bubbles / Strength",
		int widgetWidth = STRENGTH_WIDTH,
	]],

	int threshold_mode = 0
	[[
		string widget = "mapper",
		string label = "Threshold",
		string options =
			"None:0"
			"|Above:1"
			"|Below:2",
		string help = "Keeps noise above or below a certain threshold.",
		int connectable = 0,
		string packName = "Threshold / Strength",
	]],

	float threshold_strength = 0.5
	[[
		string label = "Threshold Strength",
		string help = "The threshold value.",
		float min = 0,
		float max = 1,
		int connectable = 0,
		string packName = "Threshold / Strength",
		int widgetWidth = STRENGTH_WIDTH,
	]],

	int blackwhite_thresh = 1
	[[
		string label = "Black and White Threshold",
		string help = "If enabled, the noise that passes through threshold is pure white.",
		string widget = "checkBox",
		int connectable = 0,
	]],

	SPACER(1)

	int over_sampling = 0
	[[
		string widget = "mapper",
		string label = "Over-Sampling",
		string options =
			"None:0"
			"|Rings:1"
			"|Pinch:2",
		string help = "The oversampling affects the noise coordinate used to acquire the noise. From a visual perspective, 'rings' creates circular patterns in darker areas. Pinch creates crease lines directed towards peaks.",
		int connectable = 0,
		string packName = "Over-Sampling / Strength",
	]],

	float oversampling_strength = 1
	[[
		string label = "Over-Sampling Strength",
		string help = "Increase or decrease the over-sampling amount.",
		string packName = "Over-Sampling / Strength",
		int connectable = 0,
		int widgetWidth = STRENGTH_WIDTH,
	]],

	int oversampling_noise_type = -1
	[[
		string widget = "mapper",
		string label = "Over-Sampling Noise",
		string options =
			"Same:-1"
			"|Simplex:0"
			"|Fractal:1"
			"|Fractal Lines:2",
		string help = "The type of noise to over-sample. By default, same type as 'Noise Type'.",
		int connectable = 0,
		string packName = "Over-Sampling Noise / Blend",
	]],

	int overampling_blend = 8
	[[
		string widget = "mapper",
		string label = "Over-Sampling Blend",
		string options =
			"Overlay:9"
			"|Replace:1"
			"|Screen:10"
			"|Average:2"
			"|Lighten:7"
			"|Darken:8"
			"|Difference:11"
			"|Soft Light:12"
			"|Add:3"
			"|Substract:4"
			"|Multiply:5"
			"|Divide:6"
			,
		string help = "How to blend the over-sampled noise.",
		int connectable = 0,
		string packName = "Over-Sampling Noise / Blend",
	]],

	SPACER(2)

	int girth_mode = 0
	[[
		string widget = "mapper",
		string label = "Girth",
		string options =
			"None:0"
			"|Bubbly:1"
			"|Caustics:2",
		string help = "Bubbly expands the noise, caustics squeezes it.\nNote : Caustics don't play well with Bubbles noise mode.",
		int connectable = 0,
		string packName = "Girth / Strength",
	]],

	float girth_strength = 1
	[[
		string label = "Girth Strength",
		string help = "Increase or decrease the girth multiplier or divider.",
		string packName = "Girth / Strength",
		float min = 0.001,
		int connectable = 0,
		int widgetWidth = STRENGTH_WIDTH,
	]],

	int girth_threshold = 0
	[[
		string widget = "mapper",
		string label = "Girth-Threshold",
		string options =
			"None:0"
			"|Flatten Top:1"
			"|Emphasize Top:2",
		string help = "Limits the girth above/below a certain value. Does nothing if no girth.",
		string packName = "Girth-Threshold / Strength",
		int connectable = 0,
	]],

	float girth_threshold_strength = 0.5
	[[
		string label = "Girth-Threshold Strength",
		string help = "The girth threshold limit value.",
		string packName = "Girth-Threshold / Strength",
		int connectable = 0,
		int widgetWidth = STRENGTH_WIDTH,
		float min = 0,
		float max = 0.999,
	]],

	SPACER(3)

	float sampling_dist = 1
	[[
		string label = "Sampling Distance",
		string help = "The 'search range' of the neighbours. Animate with scene time for interesting results.",
	]],

	float phase = 0
	[[
		string label = "Phase",
		string help = "The 4th coordinate of the noise. Animate with scene time for interesting results.",
	]],

	float ramp_out = 0
	[[
		string label = "Ramp Output",
		string help = "Interpolates final result. Positive is exponential, negative is logarithmic and '0' is linear interpolation (none).",
		int connectable = 0,
		string packName = "Ramp / Clamp Output",
	]],

	int clamp_out = 1
	[[
		string label = "Clamp Output",
		string help = "Clamps the output value to [0..1].",
		string widget = "checkBox",
		int connectable = 0,
		string packName = "Ramp / Clamp Output",
	]],

	SPACER(4)

	float uv_scale = 1.0
	[[
		string label = "UV Scale",
		string help = "Scale your UVWs up or down. For more betterer transformations, use UVW Transform node.",
		int connectable = 0,
	]],

	point uvw = point(u, v, 0)
	[[
		string label = "UVW",
		string help = "Transformed UVW coordinates. Animate 'w' with scene time for interesting results.",
	]],

	output float Out = 0,
	output vector VectorDisplacement = 0
)
{
	float epsilon = 0.00001;
	point orig_coord = uvw * uv_scale;
	point coord = orig_coord;
	vector grad = 0;
	float noise_v = 0;
	float orig_noise = 0;

	{
		// Gets wonky at very low sampling distances.
		float sd = fabs(sampling_dist) < 0.05 ? 0.05 : sampling_dist;

		// Compute a 3x3 matrix of surrounding samples to the currently
		// rendered point.
		matrix sample_area = noise_3x3(noise_type, coord, phase, vector(sd, 0, 0), vector(0, sd, 0));
		noise_v = sample_area[1][1];
		orig_noise = noise_v;

		// Compute gradient of noise.
		grad = fea_sobel_gradient(sample_area);
	}

	float mag = length(grad);
	float rad_dir = atan2(grad[1], grad[0]);
	float dir = (degrees(rad_dir) + 180) / 360;
	dir = fmod(dir + (camo_seed / 360), 1);

	// Camo
	noise_v = fea_blend(camo_mode, noise_v, dir);

	// Bubbles
	noise_v = fea_blend(bubbles_mode, noise_v, mag * bubbles_strength);

	// // Threshold
	// if (threshold_mode == 1) {
	// 	// above
	// 	if (noise_v < threshold_strength) {
	// 		noise_v = 0.0;
	// 	} else if (blackwhite_thresh) {
	// 		noise_v = 1.0;
	// 	}
	// } else if (threshold_mode == 2) {
	// 	// below
	// 	if (noise_v > threshold_strength) {
	// 		noise_v = 0.0;
	// 	} else if (blackwhite_thresh) {
	// 		noise_v = 1.0;
	// 	}
	// }

	// Over-sampling.
	if (over_sampling == 1) {
		// ring
		// coord += grad * oversampling_strength;

		// coord += mag * oversampling_strength;
		// coord = dir;
		coord = normalize(grad);
	} else if (over_sampling == 2) {
		// pinch
		coord += normalize(grad) * oversampling_strength;
	}

	if (over_sampling != 0) {
		int os_noise_type = noise_type;
		if (oversampling_noise_type != -1) {
			os_noise_type = oversampling_noise_type;
		}

		float os_noise = custom_noise(os_noise_type, coord, phase);
		noise_v = fea_blend(overampling_blend, noise_v, os_noise);
	}

	// Threshold
	if (threshold_mode == 1) {
		// above
		if (noise_v < threshold_strength) {
			noise_v = 0.0;
		} else if (blackwhite_thresh) {
			noise_v = 1.0;
		}
	} else if (threshold_mode == 2) {
		// below
		if (noise_v > threshold_strength) {
			noise_v = 0.0;
		} else if (blackwhite_thresh) {
			noise_v = 1.0;
		}
	}


	// The threshold acts invertly dependending on girth,
	// flip it so UI makes sense.
	if (girth_threshold == 1) {
		// flatten
		if (girth_mode == 2) {
			mag = flatten_top(mag, girth_threshold_strength);
		} else {
			mag = emphasize_top(mag, girth_threshold_strength);
		}
	} else if (girth_threshold == 2) {
		// emphasize
		if (girth_mode == 2) {
			mag = emphasize_top(mag, girth_threshold_strength);
		} else {
			mag = flatten_top(mag, girth_threshold_strength);
		}
	}

	if (girth_mode == 1) {
		mag *= girth_strength;
		noise_v *= mag;
	} else if (girth_mode == 2) {
		// Caustics.
		mag *= 10;
		mag *= (1.0 / girth_strength);
		noise_v /= mag;
	}

	if (clamp_out) {
		noise_v = clamp(noise_v, 0, 1);
	}

	if (ramp_out != 0) {
		noise_v = fea_interp(ramp_out, noise_v);
	}

	Out = noise_v;

	{
		vector coord_disp = coord - orig_coord;
		// vector disp = vector(-coord_disp[0], -coord_disp[1], Out);
		vector disp = vector(coord_disp[0], coord_disp[1], Out);
		VectorDisplacement = disp;
	}
}