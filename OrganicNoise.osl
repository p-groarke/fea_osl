// Organic Noise Shader - Caustics, bubbly, and weird noises.
// Organic Noise by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#include "D:\code\3dsmax-plugins\OSL\FeaOSL\fea.osl"

#define noise_t int

// Simplex:0
// Fractal:1
// Fractal Lines:2
// Fractal Inverse:3
#define custom_noise_opts \
		"Simplex:0" \
		"|Fractal Light:3" \
		"|Fractal Dark:1" \
		"|Fractal Lines:2"

float custom_noise(noise_t noise_type, vector coord, float phase) {
	// Minimize calls to noise.
	float ret = noise("simplex", coord, phase);

	if (noise_type == 0) {
		// simplex
		ret = (ret + 1) * 0.5;
	} else if (noise_type == 1) {
		// fractal
		ret = fabs(ret);
	} else if (noise_type == 2) {
		// fractal lines
		ret = 1 - fabs(ret);
		if (ret <= 0.99) {
			ret = 0;
		}
	} else if (noise_type == 3) {
		// fractal inverse
		ret = 1 - fabs(ret);
	}

	return ret;
}

// Returns a 3x3 matrix of noise values around
// center coords x,y.
matrix noise_3x3(noise_t noise_type, vector coord, float phase, vector xmove, vector ymove) {
	matrix ret = 0;
	// vector coord = vector(c[0], c[1], 0);

	// topleft
	{
		point p = coord - xmove + ymove;
		ret[0][0] = custom_noise(noise_type, p, phase);
	}
	// topcenter
	{
		point p = coord + ymove;
		ret[0][1] = custom_noise(noise_type, p, phase);
	}
	// topright
	{
		point p = coord + xmove + ymove;
		ret[0][2] = custom_noise(noise_type, p, phase);
	}
	// middleleft
	{
		point p = coord - xmove;
		ret[1][0] = custom_noise(noise_type, p, phase);
	}
	// middlecenter
	{
		point p = coord;
		ret[1][1] = custom_noise(noise_type, p, phase);
	}
	// middleright
	{
		point p = coord + xmove;
		ret[1][2] = custom_noise(noise_type, p, phase);
	}
	// bottomleft
	{
		point p = coord - xmove - ymove;
		ret[2][0] = custom_noise(noise_type, p, phase);
	}
	// bottomcenter
	{
		point p = coord - ymove;
		ret[2][1] = custom_noise(noise_type, p, phase);
	}
	// bottomright
	{
		point p = coord + xmove - ymove;
		ret[2][2] = custom_noise(noise_type, p, phase);
	}

	return ret;
}

float flatten_top(float mag, float thresh) {
	return mag < thresh ? thresh : mag;
}

float emphasize_top(float mag, float thresh) {
	// Also flip the threshold for UI purposes.
	return mag > 1 - thresh ? 1 - thresh : mag;
}


shader OrganicNoise
[[
	string help  =
		"<h3>Organic Noise</h3>"
		"Modulates and filters OSL noises to produce organic looking noises. Garden variety of caustic, fleshy and weird noises."
		,
	string label = "Organic Noise"
]]
(
	int noise_type = 0
	[[
		string widget = "mapper",
		string label = "Noise Type",
		string options =
			custom_noise_opts
			,
		string help = "The source noise type. 'Fractal lines' doesn't play well with most options, but is there because why not.",
		int connectable = 0,
	]],

	int noise_effect = 0
	[[
		string widget = "mapper",
		string label = "Noise Effect",
		string options =
			"None:0"
			"|Exponentize:1"
			"|Logarithmize:2"
			"|Sharpen:3"
			"|Blur:4"
			"|Emboss:5"
			"|Outline:6"
			,
		string help = "Applies an extra effect on your base noise.",
		int connectable = 0,
	]],

	int camo_mode = 0
	[[
		string widget = "mapper",
		string label = "Camo",
		string options =
			fea_blend_opts
			,
		string help = "Gives a 'camouflage' look to the noise.",
		int connectable = 0,
		string packName = "Camo / Angle",
	]],

	float camo_angle = 0
	[[
		string label = "Camo Seed",
		string help = "An angle used to tweak 'camo', 0 to 360 degrees.",
		float min = 0,
		float max = 1,
		int connectable = 0,
		string packName = "Camo / Angle",
		int widgetWidth = FEA_RPACK_W,
	]],

	int bubbles_mode = 0
	[[
		string widget = "mapper",
		string label = "Bubbles",
		string options =
			fea_blend_opts
			,
		string help = "Gives a 'bubbly' thicker look to the noise.",
		int connectable = 0,
		string packName = "Bubbles / Strength",
	]],

	float bubbles_strength = 1.0
	[[
		string label = "Bubbles Strength",
		string help = "Affects bubbles strength.",
		float min = 0,
		float max = 1,
		int connectable = 0,
		string packName = "Bubbles / Strength",
		int widgetWidth = FEA_RPACK_W,
	]],

	int splats_mode = 0
	[[
		string widget = "mapper",
		string label = "Splats",
		string options =
			fea_blend_opts
			,
		string help = "Filters the noise according to a direction, giving 'splats' as a result.",
		int connectable = 0,
		string packName = "Splats / Angle",
	]],

	float splats_angle = 0.0
	[[
		string label = "Splats Direction",
		string help = "Affects orientation of splats.",
		float min = 0,
		float max = 1,
		int connectable = 0,
		string packName = "Splats / Angle",
		int widgetWidth = FEA_RPACK_W,
	]],

	FEA_SPACER(1)

	int over_sampling = 0
	[[
		string widget = "mapper",
		string label = "Over-Sampling",
		string options =
			"None:0"
			"|Rings:1"
			"|Pinch:2",
		string help = "The oversampling affects the noise coordinate used to acquire the noise. From a visual perspective, 'rings' creates circular patterns in darker areas. Pinch creates crease lines directed towards peaks.",
		int connectable = 0,
		string packName = "Over-Sampling / Strength",
	]],

	float oversampling_strength = 1
	[[
		string label = "Over-Sampling Strength",
		string help = "Increase or decrease the over-sampling amount.",
		string packName = "Over-Sampling / Strength",
		int connectable = 0,
		int widgetWidth = FEA_RPACK_W,
	]],

	int oversampling_noise_type = -1
	[[
		string widget = "mapper",
		string label = "Over-Sampling Noise",
		string options =
			"Same:-1|"
			custom_noise_opts
			,
		string help = "The type of noise to over-sample. By default, same type as 'Noise Type'.",
		int connectable = 0,
		string packName = "Over-Sampling Noise / Blend",
	]],

	int overampling_blend = 8
	[[
		string widget = "mapper",
		string label = "Over-Sampling Blend",
		string options =
			fea_blend_opts
			,
		string help = "How to blend the over-sampled noise.",
		int connectable = 0,
		string packName = "Over-Sampling Noise / Blend",
	]],

	FEA_SPACER(2)

	int girth_mode = 0
	[[
		string widget = "mapper",
		string label = "Girth",
		string options =
			"None:0"
			"|Bubbly:1"
			"|Caustics:2",
		string help = "Bubbly expands the noise, caustics squeezes it.\nNote : Caustics don't play well with Bubbles noise mode.",
		int connectable = 0,
		string packName = "Girth / Strength",
	]],

	float girth_strength = 1
	[[
		string label = "Girth Strength",
		string help = "Increase or decrease the girth multiplier or divider.",
		string packName = "Girth / Strength",
		float min = 0.001,
		int connectable = 0,
		int widgetWidth = FEA_RPACK_W,
	]],

	int girth_threshold = 0
	[[
		string widget = "mapper",
		string label = "Girth-Threshold",
		string options =
			"None:0"
			"|Flatten Top:1"
			"|Emphasize Top:2",
		string help = "Limits the girth above/below a certain value. Does nothing if no girth.",
		string packName = "Girth-Threshold / Strength",
		int connectable = 0,
	]],

	float girth_threshold_strength = 0.5
	[[
		string label = "Girth-Threshold Strength",
		string help = "The girth threshold limit value.",
		string packName = "Girth-Threshold / Strength",
		int connectable = 0,
		int widgetWidth = FEA_RPACK_W,
		float min = 0,
		float max = 0.999,
	]],

	FEA_SPACER(3)

	float sampling_dist = 1
	[[
		string label = "Sampling Distance",
		string help = "The 'search range' of the neighbours.",
		int connectable = 0,
	]],

	float phase = 0
	[[
		string label = "Phase",
		string help = "The 4th coordinate of the noise. Animate with scene time for interesting results.",
	]],

	float ramp_out = 0
	[[
		string label = "Ramp Output",
		string help = "Interpolates final result. Positive is exponential, negative is logarithmic and '0' is linear interpolation (none).",
		int connectable = 0,
		string packName = "Ramp / Clamp Output",
	]],

	int clamp_out = 1
	[[
		string label = "Clamp Output",
		string help = "Clamps the output value to [0..1].",
		string widget = "checkBox",
		int connectable = 0,
		string packName = "Ramp / Clamp Output",
	]],

	FEA_SPACER(5)

	float uv_scale = 1.0
	[[
		string label = "UV Scale",
		string help = "Scale your UVWs up or down. For more betterer transformations, use UVW Transform node.",
		int connectable = 0,
	]],

	point uvw = point(u, v, 0)
	[[
		string label = "UVW",
		string help = "Transformed UVW coordinates. Animate 'w' with scene time for interesting results.",
	]],

	output float Out = 0
	// output vector VectorDisplacement = 0
)
{
	float epsilon = 0.00001;
	point orig_coord = uvw * uv_scale;
	point coord = orig_coord;
	vector grad = 0;
	matrix sample_area;
	float noise_v = 0;
	float sample_distance = 0.05;

	{
		// Gets wonky at very low sampling distances.
		sample_distance = fabs(sampling_dist) < 0.05 ? 0.05 : sampling_dist;

		// Compute a 3x3 matrix of surrounding samples to the currently
		// rendered point.
		sample_area = noise_3x3(noise_type, coord, phase,
				vector(sample_distance, 0, 0), vector(0, sample_distance, 0));
		noise_v = sample_area[1][1];

		// Compute gradient of noise.
		grad = fea_sobel_gradient(sample_area);
	}

	// // line experiment, Simplex lines.
	// {
	// 	// vector new_coord = coord + (noise_v * 2 - 1);
	// 	vector new_coord = coord + grad;
	// 	noise_v = abs(sin((new_coord[0] + new_coord[1]) * 10.0));
	// 	sample_area[1][1] = noise_v;
	// }

	{
		// noise_v = abs(sample_area[0][1] - sample_area[1][1]) + abs(sample_area[1][0] - sample_area[1][1]);
		// if (abs(sample_area[0][1] - sample_area[1][1]) < 0.01) {
		// 	noise_v *= 2;
		// 	// int x = floor(coord[0]);
		// 	// if ((x % 2) == 0) {
		// 	// 	noise_v = 0;
		// 	// }
		// }

		// if (abs(sample_area[1][0] - sample_area[1][1]) < 0.01) {
		// 	noise_v *= 2;
		// }

		// if (abs(sample_area[0][0] - sample_area[1][1]) < 0.01) {
		// 	noise_v *= 2;
		// }

		// if (abs(sample_area[2][0] - sample_area[1][1]) < 0.01) {
		// 	noise_v *= 2;
		// }

		// vector noise_dir = fea_angle_to_vec(fea_per_to_rad(noise_v));
		// matrix area_dirs;
		// float tot = 0;
		// for (int i = 0; i < 3; ++i) {
		// 	for (int j = 0; j < 3; ++j) {
		// 		tot += sample_area[i][j];
		// 	}
		// }
		// tot /= 9;
		// noise_v = tot;
		// if (abs(dot(noise_dir, vector(1,0,0))) < 0.95) {
		// 	noise_v = 0;
		// }
	}


	if (noise_effect == 1) {
		// Exponent
		noise_v = fea_interp(10, noise_v);
	} else if (noise_effect == 2) {
		// Logarithm
		noise_v = fea_interp(-10, noise_v);
	} else if (noise_effect == 3) {
		// sharpen
		noise_v = fea_sharpen(sample_area);
	} else if (noise_effect == 4) {
		// blur
		noise_v = fea_blur(sample_area);
	} else if (noise_effect == 5) {
		// emboss
		noise_v = fea_emboss(sample_area);
	} else if (noise_effect == 6) {
		// outline
		noise_v = fea_outline(sample_area);
	}



	float mag = length(grad);
	float dir = atan2(grad[1], grad[0]);

	// Camo
	{
		float camo_dir = fea_rad_to_per(dir + M_PI) + camo_angle;
		camo_dir = fmod(camo_dir, 1);
		noise_v = fea_blend(camo_mode, noise_v, camo_dir);
	}

	// Bubbles
	noise_v = fea_blend(bubbles_mode, noise_v, mag * bubbles_strength);

	// Squeeze?
	{
		float s = fea_per_to_rad(splats_angle);
		vector axis = fea_angle_to_vec(s);
		float val = abs(dot(normalize(grad), axis));
		noise_v = fea_blend(splats_mode, noise_v, val);
	}

	// Over-sampling.
	if (over_sampling == 1) {
		// ring
		coord += grad * oversampling_strength;

		// coord += mag * oversampling_strength;
		// coord = dir;
		// coord = normalize(grad);
	} else if (over_sampling == 2) {
		// pinch
		coord += normalize(grad) * oversampling_strength;
	}

	if (over_sampling != 0) {
		int os_noise_type = noise_type;
		if (oversampling_noise_type != -1) {
			os_noise_type = oversampling_noise_type;
		}

		float os_noise = custom_noise(os_noise_type, coord, phase);
		noise_v = fea_blend(overampling_blend, noise_v, os_noise);
	}

	// The threshold acts invertly dependending on girth,
	// flip it so UI makes sense.
	if (girth_threshold == 1) {
		// flatten
		if (girth_mode == 2) {
			mag = flatten_top(mag, girth_threshold_strength);
		} else {
			mag = emphasize_top(mag, girth_threshold_strength);
		}
	} else if (girth_threshold == 2) {
		// emphasize
		if (girth_mode == 2) {
			mag = emphasize_top(mag, girth_threshold_strength);
		} else {
			mag = flatten_top(mag, girth_threshold_strength);
		}
	}

	if (girth_mode == 1) {
		mag *= girth_strength;
		noise_v *= mag;
	} else if (girth_mode == 2) {
		// Caustics.
		mag *= 10;
		mag *= (1.0 / girth_strength);
		noise_v /= mag;
	}

	if (ramp_out != 0) {
		noise_v = fea_interp(ramp_out, noise_v);
	}

	if (clamp_out) {
		noise_v = clamp(noise_v, 0, 1);
	}

	Out = noise_v;

	// Removed for time being. Needs some r&r.
	// {
	// 	vector coord_disp = coord - orig_coord;
	// 	// vector disp = vector(-coord_disp[0], -coord_disp[1], Out);
	// 	vector disp = vector(coord_disp[0], coord_disp[1], Out);
	// 	VectorDisplacement = disp;
	// }
}