// Voronoi Shader
// Voronoi by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#include "D:\code\3dsmax-plugins\OSL\FeaOSL\fea.osl"

#define FEA_STABLE_EPS 1000.0

// For more details on all this, see :
// https://iquilezles.org/articles/voronoilines/
// https://www.shadertoy.com/view/4lKGRG
// https://iquilezles.org/articles/smin/
// https://iquilezles.org/articles/smoothvoronoi/

// TODO : move to fea.osl

// // exponential smooth min (k=32)
// float smin( float a, float b, float k )
// {
//     float res = exp2( -k*a ) + exp2( -k*b );
//     return -log2( res )/k;
// }
// // power smooth min (k=8)
// float smin( float a, float b, float k )
// {
//     a = pow( a, k ); b = pow( b, k );
//     return pow( (a*b)/(a+b), 1.0/k );
// }
// // root smooth min (k=0.01)
// float smin( float a, float b, float k )
// {
//     float h = a-b;
//     return 0.5*( (a+b) - sqrt(h*h+k) );
// }
// // polynomial smooth min
// float sminCubic( float a, float b, float k )
// {
//     float h = max( k-abs(a-b), 0.0 )/k;
//     return min( a, b ) - h*h*h*k*(1.0/6.0);
// }



// Hash type enum ui options.
#define fea_hash_opts \
		"OSL:0" \
		"|IQ:1"

// Hashes the given vector p according to dimension and with hash type.
vector fea_hash(int dimensions, int hash_type, float seed, vector p) {
	if (dimensions == 1) {
		if (hash_type == 0) {
			return fea_hash1_osl(seed, p);
		} else if (hash_type == 1) {
			return fea_hash1_iq(seed, p);
		}
	} else if (dimensions == 2) {
		if (hash_type == 0) {
			return fea_hash2_osl(seed, p);
		} else if (hash_type == 1) {
			return fea_hash2_iq(seed, p);
		}
	} else if (dimensions == 3) {
		if (hash_type == 0) {
			return fea_hash3_osl(seed, p);
		} else if (hash_type == 1) {
			return fea_hash3_iq(seed, p);
		}
	}
	return vector(0);
}
vector fea_hash(int dimensions, int hash_type, vector p) {
	return fea_hash(dimensions, hash_type, 0.0, p);
}

#define fea_mk_rnd_pnts_arr_size 64
#define fea_mk_rnd_pnts_iters 4
#define fea_mk_rnd_pnts_off 1.5

// A helper that acts like a std::vector.
fea_runtime_array(fea_rnd_pts, point, fea_mk_rnd_pnts_arr_size)

// Ui for dimension options.
#define fea_dimension_opts \
		"1D:1" \
		"|2D:2" \
		"|3D:3"

// Given a coordinate 'x', generates a sample set of random points
// in the grid around the original coordinate.
//
// The points are in local space, relative to the input coordinate.
// That is, out point + x == world space point.
// And length(out point) == distance(x, random point).
//
// Specify the number of dimensions to compute, 1, 2 or 3.
// Provide the hash_func enum value (see fea_hash_func_opts).
// Provide a seed to randomize points. Note the seed is not periodic.
// Provide your coordinate (dimensions will be dealt with appropriately).
// Provide an array of at minimum size fea_mk_rnd_pnts_iters ^ dimension
//
// Returns a runtime array like monstrosity, with the points.
fea_rnd_pts fea_make_random_points(int dimensions, int hash_type, float seed, point coord) {
	fea_rnd_pts ret;
	ret.size = int(pow(fea_mk_rnd_pnts_iters, dimensions));

	point mcoord = coord;
	mcoord[1] = dimensions < 2 ? 0 : mcoord[1];
	mcoord[2] = dimensions < 3 ? 0 : mcoord[2];

	point abs_grid = floor(mcoord);
	vector lcl_shade_point = fract(mcoord);

	// Given a local grid coord, generate a random point local to the input coord.
	point make_rnd_point(float i, float j, float k) {
		// Offset to neighbour grid point.
		vector offset = vector(i, j, k);

		// Given an absolute point on our grid, returns a random direction.
		vector rand_dir = fea_hash(dimensions, hash_type, seed, abs_grid + offset);

		// The random point, local to grid point (abs_grid).
		point grid_rand_point = rand_dir + offset;

		// A vector from our shading point to the random point.
		// Aka, the random point local to our shading point.
		return grid_rand_point - lcl_shade_point;
	}

	// Search around our grid point, in 1d, 2d or 3d.
	int iters = fea_mk_rnd_pnts_iters;
	int iters2 = iters * iters;
	float off = fea_mk_rnd_pnts_off;
	int k_max = dimensions < 3 ? 1 : iters;
	float k_off = dimensions < 3 ? 0.0 : off;
	int j_max = dimensions < 2 ? 1 : iters;
	float j_off = dimensions < 2 ? 0.0 : off;

	for (int k = 0; k < k_max; ++k) {
		for (int j = 0; j < j_max; ++j) {
			for (int i = 0; i < iters; ++i) {
				int idx = k * iters2 + j * iters + i;
				ret.data[idx] = make_rnd_point(
						float(i) - off,
						float(j) - j_off,
						float(k) - k_off
				);
			}
		}
	}

	return ret;
}

#define fea_random_erase_opts \
		"None:0" \
		"|Random:1" \
		"|Clouds (FBM):2" \
		"|Texture:3" \
		"|Texture Inverted:4"

// Given points local to coord,
// Erase some of the points using various random schemes.
// Modifies the pts array and its size.
void fea_random_erase(int erase_opt, float erase_strength, int hash_type, float hash_seed,
		string tex_filename, float tex_scale, float tex_offset, point coord,
		output point pts[], output int num_pts) {

	if (erase_opt == 0) {
		return;
	}

	if (erase_strength == 1.0) {
		num_pts = 0;
		return;
	}

	if (num_pts > arraylength(pts)) {
		num_pts = arraylength(pts);
	}

	int is_removed(point stable_p) {
		int ret = 0;
		if (erase_opt == 1) {
			// random
			vector e = fea_hash(1, hash_type, hash_seed, stable_p);
			if (e[0] < erase_strength) {
				ret = 1;
			}
		} else if (erase_opt == 2) {
			// clouds (fbm)
			float e = fea_fbm(3, stable_p, hash_seed) * 2.0;
			if (e < erase_strength) {
				ret = 1;
			}
		} else if (erase_opt == 3 || erase_opt == 4) {
			// texture
			point p = stable_p / tex_scale;
			p += tex_offset;
			color c = texture(tex_filename, p[0], p[1], "wrap", "periodic");
			float e = fea_average(c);
			if (erase_opt == 3 && e < erase_strength) {
				ret = 1;
			} else if (erase_opt == 4 && e > erase_strength) {
				ret = 1;
			}
		}

		return ret;
	}

	for (int i = 0; i < num_pts; ++i) {
		point stable_p = fea_floor_to(pts[i] + coord, FEA_STABLE_EPS);
		if (is_removed(stable_p)) {
			pts[i] = pts[num_pts - 1];
			--num_pts;
			--i;
		}
	}
}

// Overload for fea_rnd_pts helper.
void fea_random_erase(int erase_opt, float erase_strength, int hash_type, float hash_seed,
		string tex_filename, float tex_scale, float tex_offset, point coord,
		output fea_rnd_pts rnd_pts) {
	return fea_random_erase(erase_opt, erase_strength, hash_type, hash_seed,
			tex_filename, tex_scale, tex_offset, coord, rnd_pts.data, rnd_pts.size);
}


// fea_animate_points animation options
#define fea_anim_pts_opts \
		"None:0" \
		"|Circles:1" \
		"|Slosh:2" \
		"|Back and Forth:3" \
		"|Random Walk:4" \
		"|Test:5"

// Animates an array of points (in local space to the shading coordinate).
// Offers various animations.
// Provide the hash type, phase, shading coordinate.
void fea_animate_points(int dimensions, int hash_type, float hash_seed,
		int anim_opt, float anim_strength, float phase, point coord,
		output point pts[], int num_pts) {
	if (anim_opt == 0) {
		return;
	}

	// Phase in radians.
	float phase_rad = fea_per_to_rad(phase);

	int count = min(arraylength(pts), num_pts);
	for (int i = 0; i < count; ++i) {
		point lcl_p = pts[i];

		// All our computations must be evaluated in global space.
		point p = lcl_p + coord;
		point stable_p = fea_floor_to(p, FEA_STABLE_EPS);
		vector rand_dir = fea_hash(dimensions, hash_type, hash_seed, stable_p) * 0.25 * anim_strength;
		float rand_num = (rand_dir[0] + rand_dir[1] + rand_dir[2]) * 100.0;

		if (anim_opt == 1) {
			// circles
			point other_p = p;
			other_p[0] -= rand_dir[2];
			other_p[1] -= rand_dir[0];
			other_p[2] -= rand_dir[1];
			p = rotate(p, phase_rad + rand_num, p + rand_dir, other_p);
		} else if (anim_opt == 2) {
			// slosh
			p = rotate(p, phase_rad, p + rand_dir, point(0));
		} else if (anim_opt == 3) {
			// back and forth
			p += rand_dir * sin(phase_rad + rand_dir[1] * 100.0) * rand_dir[dimensions - 1] * 10.0;
		} else if (anim_opt == 4) {
			// random walk
			p = rotate(p, phase_rad + rand_dir[0] * 100.0, p + rand_dir, point(0));
		} else if (anim_opt == 5) {
			// test
			float val = sin(phase_rad + rand_num);
			// float s = noise("simplex", val);
			// p += rand_dir * s[0];
			// point other_p = p;
			// other_p[0] -= rand_dir[2] + s[0];
			// other_p[1] -= rand_dir[0] + s[0];
			// other_p[2] -= rand_dir[1] + s[0];
			p = rotate(p, phase_rad, p + rand_dir, p * val);
		}

		// Make local again.
		pts[i] = p - coord;
	}
}

// Overload for fea_rnd_pts helper.
void fea_animate_points(int dimensions, int hash_type, float hash_seed, int anim_opt, float anim_strength, float phase, point coord, output fea_rnd_pts rnd_pts) {
	return fea_animate_points(dimensions, hash_type, hash_seed, anim_opt, anim_strength, phase, coord, rnd_pts.data, rnd_pts.size);
}


// https://en.wikipedia.org/wiki/Taxicab_geometry
float fea_distance_manhattan(point p1, point p2) {
	float ret = 0.0;
	for (int i = 0; i < 3; ++i) {
		ret += abs(p1[i] - p2[i]);
	}
	return ret;
}

// https://en.wikipedia.org/wiki/Chebyshev_distance
float fea_distance_chebyshev(point p1, point p2) {
	float ret = abs(p1[0] - p2[0]);
	for (int i = 1; i < 3; ++i) {
		ret = max(ret, abs(p1[i] - p2[i]));
	}
	return ret;
}


float fea_distance_test(point p1, point p2) {
	float denum = 0.0;
	for (int i = 0; i < 3; ++i) {
		denum += p1[i] + p2[i];
	}
	if (denum == 0.0) {
		return 0.0;
	}

	float num = fea_distance_manhattan(p1, p2);
	return num / denum;
}


// A helper that acts like a std::vector.
fea_runtime_array(fea_dists, float, fea_mk_rnd_pnts_arr_size)

// fea_distances_to_point options.
//
// Tested but not applicable : Canberra, Bray Curtis,
#define fea_distance_opts \
		"Euclidean Squared:0" \
		"|Euclidean:1" \
		"|Manhattan:2" \
		"|Chebyshev:3" \
		"|Test:5"

// Given an array of points, computes the distance of each to target_point,
// and outputs it in out_distances array.
//
// Also returns the index of the closest point.
fea_dists fea_distances_to_point(int distance_opt, point target_point, point pts[], int num_pts) {
	fea_dists ret;
	ret.size = min(arraylength(pts), num_pts);

	for (int i = 0; i < ret.size; ++i) {
		float d = 0.0;
		if (distance_opt == 0) {
			d = fea_length_squared(target_point - pts[i]);
		} else if (distance_opt == 1) {
			// euclidean
			d = length(target_point - pts[i]);
		} else if (distance_opt == 2) {
			// manhattan
			d = fea_distance_manhattan(target_point, pts[i]);
		} else if (distance_opt == 3) {
			// chebyshev
			d = fea_distance_chebyshev(target_point, pts[i]);
		} else if (distance_opt == 4) {
		} else if (distance_opt == 5) {
			// tests
		}

		ret.data[i] = d;
	}

	return ret;
}

// Overload for fea_rnd_pts helper.
fea_dists fea_distances_to_point(int distance_opt, point target_point, fea_rnd_pts pts) {
	return fea_distances_to_point(distance_opt, target_point, pts.data, pts.size);
}


// test
void fea_sort_by_distance(output point pts[], int num_pts, output float dists[], int num_dists) {
	int count = min(num_pts, num_dists);
	if (count < 2) {
		return;
	}

	int partition(int first, int last) {
		float pivot = dists[last - 1];
		int ret = first - 1;

		for (int j = first; j < last - 1; ++j) {
			if (dists[j] < pivot) {
				++ret;
				fea_swap(float, dists[ret], dists[j])
				fea_swap(point, pts[ret], pts[j])
			}
		}

		// Place pivot as first value of >= partition.
		++ret;
		fea_swap(float, dists[ret], dists[last - 1])
		fea_swap(point, pts[ret], pts[last - 1])
		return ret;
	}

	void quick_sort(int first, int last) {
		int stack[fea_mk_rnd_pnts_arr_size];
		int top = -1;
		stack[++top] = first;
		stack[++top] = last;

		while (top > 0) {
			int mlast = stack[top--];
			int mfirst = stack[top--];

			int pivot = partition(mfirst, mlast);
			if (pivot - mfirst > 1) {
				// At least 2 elements to sort.
				stack[++top] = mfirst;
				stack[++top] = pivot;
			}

			if (mlast - (pivot + 1) > 1) {
				// At least 2 elements to sort.
				stack[++top] = pivot + 1;
				stack[++top] = mlast;
			}
		}
	}

	quick_sort(0, count);
}

// Overload for fea_rnd_pts and fea_dists helpers.
void fea_sort_by_distance(output fea_rnd_pts rnd_pts, output fea_dists dists) {
	return fea_sort_by_distance(rnd_pts.data, rnd_pts.size, dists.data, dists.size);
}


// fea_voronoi blending options.
#define fea_smoothmin_opts \
		"None:0" \
		"|Metaballs:1" \
		"|Exponent:2" \
		"|Power:3"

float fea_smoothmin(int blend_opt, float blend_strength, float dists[], int num_dists, output int f1_idx) {
	if (num_dists <= 0) {
		return 10.0;
	}

	// First, massage falloff according to dimensions and other settings,
	// so it is a reasonable value.
	float falloff = blend_strength;
	if (blend_opt == 1) {
		// metaballs
		if (falloff < 0.000001) {
			falloff = 0.000001;
		}
	} else if (blend_opt == 2) {
		// exponent
		falloff = 64.0 - (falloff * 64.0);
	} else if (blend_opt == 3) {
		// power
		falloff = 16.0 - (falloff * 16.0);
	}

	float f1_dist = FEA_FLT_MAX;
	float ret = 0.0;

	int count = min(arraylength(dists), num_dists);
	for (int i = 0; i < count; ++i) {
		float d = dists[i];

		if (d < f1_dist) {
			f1_dist = d;
			f1_idx = i;
		}

		if (blend_opt == 1) {
			// metaballs
			ret += pow(1.0 / (d * d), 2.0);
			// if (distance_opt == 0) {
			// 	blended_dist += pow(1.0 / d, 2.0);
			// } else {
			// 	blended_dist += pow(1.0 / (d * d), 2.0);
			// }
		} else if (blend_opt == 2) {
			// exponent
			ret += exp2(-falloff * d);
		} else if (blend_opt == 3) {
			// power
			ret += 1.0 / pow(d, falloff);
		}
	}

	// Final massage.
	if (blend_opt == 0) {
		ret = f1_dist;
	} else if (blend_opt == 1) {
		// metaballs
		ret =  (ret / float(count)) * falloff;
	} else if (blend_opt == 2) {
		// exponent
		ret = -(1.0 / falloff) * log2(ret);
	} else if (blend_opt == 3) {
		// power
		ret = pow(1.0 / ret, 1.0 / falloff);
	}

	return ret;
}

// Overload for fea_dists helper.
float fea_smoothmin(int blend_opt, float blend_strength, fea_dists dists, output int closest_idx) {
	return fea_smoothmin(blend_opt, blend_strength, dists.data, dists.size, closest_idx);
}


// Given random points local to the currently shaded coordinate,
// returns the distance to the closest border in between closeby points (voronoi).
// Also outputs the index of the point that was used (the second closest point).
//
// Provide the index of the closest point in the point set.
float fea_voronoi_borders(int closest_idx, point pts[], int num_pts, output int second_idx) {
	if (closest_idx >= num_pts || num_pts < 2) {
		return 1.0;
	}

	point closest_pt = pts[closest_idx];
	float ret = FEA_FLT_MAX;
	for (int i = 0; i < num_pts; ++i) {
		// Skip the closest point (we are looking for second closest border).
		if (i != closest_idx) {
			point current_pt = pts[i];
			float dist_to_brdr = dot(0.5 * (closest_pt + current_pt), normalize(current_pt - closest_pt));
			// float dist_to_brdr = abs(length(current_pt) - length(closest_idx));
			// float dist_to_brdr = length((current_pt - closest_pt) / 2.0);
			if (dist_to_brdr < ret) {
				ret = dist_to_brdr;
				second_idx = i;
			}
		}
	}

	return ret;
}

// Overload for fea_rnd_pts helper.
float fea_voronoi_borders(int closest_idx, fea_rnd_pts pts, output int second_idx) {
	return fea_voronoi_borders(closest_idx, pts.data, pts.size, second_idx);
}


shader Voronoi
[[
	string help  =
		"<h3>Voronoi</h3>"
		"A voronoi / cell noise implementation."
		,
	string label = "Voronoi"
]]
(
	int in_dimensions = 3
	[[
		string label = "Dimensions",
		string help = "Evaluates the functions in 1d, 2d or 3d. The higher the dimension, the heavier the shader.<br>"
				"3d is particularly useful when rendering volumes, to eliminate seams or if your UVs contain the W component.",
		string widget = "mapper",
		string options =
			"2D:2"
			"|3D:3"
			,
		int connectable = 0,
	]],

	int in_hash_type = 0
	[[
		string label = "Hash Function",
		string help = "The core function used to generate the random points.",
		string widget = "mapper",
		string options =
			fea_hash_opts
			,
		int connectable = 0,
		string packName = "Hash Function / Seed",
	]],

	float in_hash_seed = 0.0
	[[
		string label = "Seed",
		string help = "A seed provided to the hash function.",
		int connectable = 0,
		string packName = "Hash Function / Seed",
	]],

	FEA_SPACER(0)

	int in_remove_type = 0
	[[
		string label = "Point Removal",
		string help = "Remove target points using various schemes (random, texture intensity, etc).",
		string widget = "mapper",
		string options =
			fea_random_erase_opts
			,
		int connectable = 0,
		string packName = "Point Removal / Strength",
	]],

	float in_remove_strength = 0.2
	[[
		string label = "Point Removal Strength",
		string help = "The strength (aka threshold) at which to discard points.",
		float min = 0.0,
		float max = 1.0,
		int connectable = 0,
		string packName = "Point Removal / Strength",
		int widgetWidth = FEA_RPACK_W,
	]],

	color in_entropy_color = 0
	[[
		string label = "Entropy Color",
		string help = "The options that offer a 'Map' parameter will use this input to drive calculations.<br>"
				"Feed in another noise, a texture, what have you.",
		// string widget = "filename",
		// int connectable = 0,
	]],

	string in_entropy_tex_filename = ""
	[[
		string label = "Entropy Texture",
		string help = "Options that offer a 'Texture' parameter will use this input to drive calculations.",
		string widget = "filename",
		int connectable = 0,
		string packName = "Entropy Texture / Scale",
	]],

	float in_entropy_tex_scale = 1.0
	[[
		string label = "Entropy Texture Scale",
		string help = "Scale the input texture. This matters when working in object space (no UVWs).",
		int connectable = 0,
		string packName = "Entropy Texture / Scale",
		int widgetWidth = FEA_RPACK_W,
	]],


	FEA_SPACER(1)

	int in_distance_type = 0
	[[
		string label = "Distance Metric",
		string help = "The distance function used to compute distance to points."
			"<br>Note, the euclidean is squared due to sqrt precision issues. You may take square root of the distance output if required.",
		string widget = "mapper",
		string options =
			fea_distance_opts
			,
		int connectable = 0,
	]],

	// FEA_SPACER(0),

	int in_cell_style = 0
	[[
		string label = "Cell Style",
		string help = "The style of the cell interior.",
		string widget = "mapper",
		string options =
			"Organic:0"
			"|Bubbles:1"
			"|Chiseled:2"
			"|Color:3"
			,
		int connectable = 0,
	]],

	int in_cell_smooth_type = 0
	[[
		string label = "Smoothing",
		string help = "Various options to compute the distance of one cell to another.<br>"
				"<b>Warning</b>, some options cause artifacting at extreme levels of smoothness, or with metaballs.",
		string widget = "mapper",
		string options =
			fea_smoothmin_opts
			,
		int connectable = 0,
		string packName = "Smoothing / Strength",
	]],

	float in_cell_smooth_strength = 0.5
	[[
		string label = "Smoothing Strength",
		string help = "The strength of the cell blending.<br>"
				"<b>Warning</b>, some options cause artifacting at extreme levels of smoothness, or with metaballs.",
		float min = 0.0,
		float max = 1.0,
		// int connectable = 0,
		string packName = "Smoothing / Strength",
		int widgetWidth = FEA_RPACK_W,
	]],

	int in_threshold_type = 0
	[[
		string label = "Threshold",
		string help = "Thresholds the function using various schemes.",
		string widget = "mapper",
		string options =
			"None:0"
			"|Threshold:1"
			"|Slice:2"
			"|Contours:3"
			,
		int connectable = 0,
	]],

	float in_threshold_val = 0.5
	[[
		string label = "Threshold Value",
		string help = "The value of the threshold 'slice'.",
		float min = 0.0,
		float max = 1.0,
		// int connectable = 0,
		string packName = "Threshold Value / Feather",
	]],

	float in_threshold_feather = 0.1
	[[
		string label = "Threshold Feather",
		string help = "The edge smoothness of the threshold 'slice'.",
		float min = 0.0,
		float max = 1.0,
		// int connectable = 0,
		string packName = "Threshold Value / Feather",
	]],

	FEA_SPACER(2)

	int in_draw_borders = 0
	[[
		string label = "Draw Borders",
		string help = "Render solid voronoi cell borders.",
		string widget = "checkBox",
		int connectable = 0,
	]],

	float in_border_width = 1.0
	[[
		string label = "Border Width",
		string help = "The cell border width.",
		float min = 0.0,
	]],

	float in_border_feather = 0.01
	[[
		string label = "Border Feather",
		string help = "The cell border fade amount.",
		float min = 0.001,
	]],

	color in_border_color = color(1)
	[[
		string label = "Border Color",
		string help = "The cell border color.",
	]],

	FEA_SPACER(3)

	int in_animation_type = 0
	[[
		string label = "Animation",
		string help = "Animates the points using various schemes. Pipe the scene time in the phase input to animate.",
		string widget = "mapper",
		string options =
			fea_anim_pts_opts
			,
		int connectable = 0,
		string packName = "Animation / Strength",
	]],

	float in_animation_strength = 1.0
	[[
		string label = "Animation Strength",
		string help = "The range of animation. Note, for technical reasons, the range must remain quite limited.",
		float min = 0.0,
		float max = 1.0,
		int connectable = 0,
		string packName = "Animation / Strength",
		int widgetWidth = FEA_RPACK_W,
	]],

	float in_time = 0.0
	[[
		string label = "Time (s)",
		string help = "Used to animate, animation loops at 1.",
		int timeValue = 1,
	]],

	FEA_SPACER(4)

	int in_clamp_output = 1
	[[
		string label = "Clamp Output",
		string help = "Clamps the output value between [0..1].",
		string widget = "checkBox",
		int connectable = 0,
	]],

	float in_uvw_scale = 1.0
	[[
		string label = "UVW Scale",
		string help = "Scale your UVWs up or down (or the object, if no UVWs are provided).<br>For more betterer transformations, use UVW Transform node.",
		float min = 0.00001,
		int connectable = 0,
	]],

	point in_uvw = transform("object", P)
	[[
		string label = "UVW",
		string help = "Transformed UVW coordinates. Animate 'w' with scene time for interesting results.",
	]],


	output color Out = 0,
	output vector Distance = 0
)
{

/*
	feedback
	1. blender doc of voronoi node (baseline, truly understand) cool stuff : write a color, use as function to drive
	2. additional parameter, a percentage of will i use a feature point or not.
		aka, 20% of the points

	border distortion in 3d (check iq stuff)
	smoothmin (to make border "rounded")
	modulate hash vector ( exposed)
	expose phase (animate points like iq)
	blur borders (check iq article)
	perdurbe distance of borders (makes border edges ragged)
	fractal of full function
	instead of doing distance, use blob calculation (metablobs!)
	bomb implicits (sphere == blobs, super quadratic, super ellipsoid)
		bomb random rotation

	explore not f2 - f1
	other map slot to do domain distortion
		distorter map

	crazy : gradient blur?

*/

	float entropy_tex_scale = in_entropy_tex_scale;
	float entropy_tex_offset = 0.0;
	// if (!isconnected(in_uvw)) { // not implemented?
	if (in_uvw == transform("object", P)) {
		entropy_tex_scale /= in_uvw_scale * -0.01;
		entropy_tex_offset = 0.5;
	} else {
		entropy_tex_scale /= -in_uvw_scale;
	}

	point coord = in_uvw / in_uvw_scale;
	coord[1] = in_dimensions < 2 ? 0 : coord[1];
	coord[2] = in_dimensions < 3 ? 0 : coord[2];

	// Generate a bunch of random points, local to shaded coordinate.
	// Number of actual points depends on dimension.
	fea_rnd_pts rnd_pts = fea_make_random_points(in_dimensions, in_hash_type, in_hash_seed, coord);

	fea_random_erase(in_remove_type, in_remove_strength, in_hash_type,
			in_hash_seed, in_entropy_tex_filename, entropy_tex_scale, entropy_tex_offset,
			coord, rnd_pts);

	// Animate them.
	fea_animate_points(in_dimensions, in_hash_type, in_hash_seed, in_animation_type, in_animation_strength, in_time, coord, rnd_pts);

	// Compute all distances to us (0,0 local space).
	fea_dists dists = fea_distances_to_point(in_distance_type, point(0), rnd_pts);

	// temp test
	fea_sort_by_distance(rnd_pts, dists);

	if (rnd_pts.size < 3) {
		Out = color(0);
	} else {
		// Out = dists.data[0];

		point bf2f1 = (rnd_pts.data[1] - rnd_pts.data[0]) * 0.5;// + rnd_pts.data[0];
		point bf3f1 = (rnd_pts.data[2] - rnd_pts.data[0]) * 0.5;// + rnd_pts.data[0];
		point bf3f2 = (rnd_pts.data[2] - rnd_pts.data[1]) * 0.5;// + rnd_pts.data[1];

		float f2f1 = length(bf2f1);
		// Out = smoothstep(0.9, 0.95, f2f1);
		Out = f2f1;
		// float f3f1 = length(bf3f1);
		// float f3f2 = length(bf3f2);

		// float m1 = min(f2f1, f3f1);
		// float m2 = min(f3f1, f3f2);

		// Out = m1 < m2 ? m2 - m1 : m1 - m2;

		// Out = f2f1 - f3f1 - f3f2;


		// float f2f1 = dists.data[1] - dists.data[0];
		// float f3f1 = dists.data[2] - dists.data[0];
		// float f3f2 = dists.data[2] - dists.data[1];
		// Out = min(f2f1, min(f3f1, f3f2));
	}

	return;


	// Find the closest distance to a point. Aka, voronoi.
	int f1_idx = -1;
	float dist = fea_smoothmin(in_cell_smooth_type, in_cell_smooth_strength, dists, f1_idx);
	dist = clamp(dist, 0.0, 1.0);
	// dist = smoothstep(0.0 + in_cell_smooth_strength * 0.5, 1.0 - in_cell_smooth_strength * 0.5, dist);

	// Find the distance to the closest and second closest cell border.
	int border_idx = -1;
	float border_dist = fea_voronoi_borders(f1_idx, rnd_pts, border_idx);

	// if (border_idx < 0) {
	// 	Out = color(0);
	// 	return;
	// }

	// Internal cell style
	if (in_cell_style == 0) {
		// organic
		// nothing to do

		// float lines = fea_usin((coord[0] + coord[1]) * 10.0 + dist * 1.0);
		// dist = lines;
		// dist += lines;
	} else if (in_cell_style == 1) {
		// bubbles
		dist = 1.0 - dist;
	} else if (in_cell_style == 2) {
		// chiseled
		dist = border_dist;
	}

	if (in_threshold_type == 1) {
		// threshold
		dist = smoothstep(in_threshold_val - in_threshold_feather, in_threshold_val + in_threshold_feather, dist);
	} else if (in_threshold_type == 2) {
		// slice
		float diff = abs(in_threshold_val - dist);
		// diff = fea_interp(-10.0, diff);
		dist = 1.0 - smoothstep(0.0, in_threshold_feather, diff);
	} else if (in_threshold_type == 3) {
		// contours
		dist = clamp(dist, 0.0, 1.0);
		if (dist != 0.0 && dist != 1.0) {
			float d = fmod(dist, in_threshold_val);
			float f = in_threshold_feather * 0.1;
			dist = smoothstep(in_threshold_val - f, in_threshold_val, d);
			dist += 1.0 - smoothstep(0.0, f, d);
		} else {
			dist = 0.0;
		}
	}

	Out = dist;

	// TODO : color will be a seperate thing
	if (in_cell_style == 3) {
		// color, TODO
		// temp, make global coord
		Out = (coord + rnd_pts.data[f1_idx]) * 0.1;
	}

	// Borders
	if (in_draw_borders) {
		float w = in_border_width * 0.1;
		float eps = in_border_feather * 0.1;
		float p = 1.0 - smoothstep(w, w + eps, border_dist);
		Out = mix(Out, in_border_color, p);
	}

	if (in_clamp_output) {
		Out = clamp(Out, color(0), color(1));
	}
}