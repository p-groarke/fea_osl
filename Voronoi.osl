// Voronoi Shader
// Voronoi by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt

#include "D:\code\3dsmax-plugins\OSL\FeaOSL\fea.osl"

// For more details on all this, see :
// https://iquilezles.org/articles/voronoilines/
// https://www.shadertoy.com/view/4lKGRG

// TODO : move to fea.osl
vector fea_hash1_iq(float seed, vector p) {
	return vector(fract(sin(p[0] + seed) * 43758.5453), 0.0, 0.0);
}
vector fea_hash2_iq(float seed, vector p) {
	vector q = vector(
		dot(p, vector(127.1, 311.7, 0.0)),
		dot(p, vector(269.5, 183.3, 0.0)),
		0.0
	);
	return fract(sin(q + seed) * 43758.5453);
}
vector fea_hash3_iq(float seed, vector p) {
	vector q = vector(
		dot(p, vector(127.1, 311.7, 0.0)),
		dot(p, vector(269.5, 183.3, 0.0)),
		dot(p, vector(419.2, 371.9, 0.0))
	);

	return fract(sin(q + seed) * 43758.5453);
}


// Hash type enum ui options.
#define fea_hash_opts \
		"OSL:0" \
		"|IQ:1"


// Hashes the given vector p according to dimension and with hash type.
vector fea_hash(int dimensions, int hash_type, float seed, vector p) {
	if (dimensions == 1) {
		if (hash_type == 0) {
			return fea_hash1_osl(seed, p);
		} else if (hash_type == 1) {
			return fea_hash1_iq(seed, p);
		}
	} else if (dimensions == 2) {
		if (hash_type == 0) {
			return fea_hash2_osl(seed, p);
		} else if (hash_type == 1) {
			return fea_hash2_iq(seed, p);
		}
	} else if (dimensions == 3) {
		if (hash_type == 0) {
			return fea_hash3_osl(seed, p);
		} else if (hash_type == 1) {
			return fea_hash3_iq(seed, p);
		}
	}
	return vector(0);
}
vector fea_hash(int dimensions, int hash_type, vector p) {
	return fea_hash(dimensions, hash_type, 0.0, p);
}


// Ui for dimension options.
#define fea_dimension_opts \
		"1D:1" \
		"|2D:2" \
		"|3D:3"

#define fea_mk_rnd_pnts_iters 4
#define fea_mk_rnd_pnts_arr_size 64
#define fea_mk_rnd_pnts_off 1.5

// Given a coordinate 'x', generates a sample set of random points
// in the grid around the original coordinate.
//
// The points are in local space, relative to the input coordinate.
// That is, out point + x == world space point.
// And length(out point) == distance(x, random point).
//
// Specify the number of dimensions to compute, 1, 2 or 3.
// Provide the hash_func enum value (see fea_hash_func_opts).
// Provide a seed to randomize points. Note the seed is not periodic.
// Provide your coordinate (dimensions will be dealt with appropriately).
// Provide an array of at minimum size fea_mk_rnd_pnts_iters ^ dimension
void fea_make_random_points(int dimensions, int hash_type, float seed, point x, point out_points[]) {
	int arr_len = arraylength(out_points);
	if (arr_len < int(pow(fea_mk_rnd_pnts_iters, dimensions))) {
		return;
	}

	point mcoord = x;
	mcoord[1] = dimensions < 2 ? 0 : mcoord[1];
	mcoord[2] = dimensions < 3 ? 0 : mcoord[2];

	point abs_grid = floor(mcoord);
	vector lcl_shade_point = fract(mcoord);

	// Given a local grid coord, generate a random point local to the input coord.
	point make_rnd_point(float i, float j, float k) {
		// Offset to neighbour grid point.
		vector offset = vector(i, j, k);

		// Given an absolute point on our grid, returns a random direction.
		vector rand_dir = fea_hash(dimensions, hash_type, seed, abs_grid + offset);

		// The random point, local to grid point (abs_grid).
		point grid_rand_point = rand_dir + offset;

		// A vector from our shading point to the random point.
		// Aka, the random point local to our shading point.
		return grid_rand_point - lcl_shade_point;
	}
	// Search around our grid point, in 1d, 2d or 3d.
	int iters = fea_mk_rnd_pnts_iters;
	int iters2 = iters * iters;
	float off = fea_mk_rnd_pnts_off;
	int k_max = dimensions < 3 ? 1 : iters;
	float k_off = dimensions < 3 ? 0.0 : off;
	int j_max = dimensions < 2 ? 1 : iters;
	float j_off = dimensions < 2 ? 0.0 : off;

	for (int k = 0; k < k_max; ++k) {
		for (int j = 0; j < j_max; ++j) {
			for (int i = 0; i < iters; ++i) {
				int idx = k * iters2 + j * iters + i;
				out_points[idx] = make_rnd_point(
						float(i) - off,
						float(j) - j_off,
						float(k) - k_off
				);
			}
		}
	}
}

// fea_animate_points animation options
#define fea_anim_pts_opts \
		"None:0" \
		"|Circles:1" \
		"|Slosh:2" \
		"|Test:3"

// Animates an array of points (in local space to the shading coordinate).
// Offers various animations.
// Provide the hash type, phase, shading coordinate.
void fea_animate_points(int dimensions, int anim_opt, int hash_type, float phase, point coord, output point pts[], int num_pts) {
	if (anim_opt == 0) {
		return;
	}

	// Phase in radians.
	float phase_rad = fea_per_to_rad(phase) * 0.5;

	for (int i = 0; i < num_pts; ++i) {
		point lcl_p = pts[i];

		// All our computations must be evaluated in global space.
		point p = lcl_p + coord;
		point stable_p = fea_floor_to(p, 100.0);
		vector rand_dir = fea_hash(dimensions, hash_type, stable_p) * 0.25;

		if (anim_opt == 1) {
			// circles
			point other_p = p;
			other_p[0] -= rand_dir[2];
			other_p[1] -= rand_dir[0];
			other_p[2] -= rand_dir[1];
			p = rotate(p, phase_rad, p + rand_dir, other_p);
		} else if (anim_opt == 2) {
			// slosh
			p = rotate(p, phase_rad, p + rand_dir, point(0));
		} else if (anim_opt == 3) {
			// test
			p[0] += fea_usin(phase_rad + rand_dir[0]) * 0.5;
			p[1] += fea_usin(phase_rad + rand_dir[1]) * 0.5;
			p[2] += fea_usin(phase_rad + rand_dir[2]) * 0.5;
			// torus
			// p[0] = (0.1 + 0.2 * cos(p[1])) * cos(p[0]);
			// p[1] = (0.1 + 0.2 * cos(p[1])) * sin(p[0]);
			// p[2] = 0.2 * sin(p[1]);
		}


		// Make local again.
		pts[i] = p - coord;
	}
}



// https://en.wikipedia.org/wiki/Taxicab_geometry
float fea_distance_manhattan(point p1, point p2) {
	float ret = 0.0;
	for (int i = 0; i < 3; ++i) {
		ret += abs(p1[i] - p2[i]);
	}
	return ret;
}

// https://en.wikipedia.org/wiki/Chebyshev_distance
float fea_distance_chebyshev(point p1, point p2) {
	float ret = abs(p1[0] - p2[0]);
	for (int i = 1; i < 3; ++i) {
		ret = max(ret, abs(p1[i] - p2[i]));
	}
	return ret;
}

point fea_mean(point pts[], int num_pts) {
	point ret;
	if (num_pts == 0) {
		return ret;
	}

	for (int i = 0; i < num_pts; ++i) {
		ret += pts[i];
	}

	return ret / float(num_pts);
}

// https://en.wikipedia.org/wiki/Mahalanobis_distance
float fea_distance_mahalanobis(point p1, point pts[], int num_pts) {
	point mean_point = fea_mean(pts, num_pts);

	// test
	return distance(p1, mean_point);
}

float fea_distance_test(point p1, point p2) {
	float denum = 0.0;
	for (int i = 0; i < 3; ++i) {
		denum += p1[i] + p2[i];
	}
	if (denum == 0.0) {
		return 0.0;
	}

	float num = fea_distance_manhattan(p1, p2);
	return num / denum;
}



// fea_voronoi distance options.
//
// Tested but not applicable : Canberra, Bray Curtis,
#define fea_distance_opts \
		"Default (Euclidean Squared):0" \
		"|Euclidean:1" \
		"|Manhattan:2" \
		"|Chebyshev:3" \
		"|Mahalanobis:4" \
		"|Test:5"

// fea_voronoi blending options.
#define fea_distance_blend_opts \
		"None:0" \
		"|Metaballs:1" \
		"|Exponent:2" \
		"|Power:3"


// Given random points local to the currently shaded sample,
// returns the distance to the closest point (and its index).
// Aka, voronoi.
float fea_voronoi(int distance_opt, int blend_opt, float blend_falloff, point pts[], int num_pts, output int out_idx) {
	float min_dist = FEA_FLT_MAX;
	float blended_dist = 0.0;

	for (int i = 0; i < num_pts; ++i) {
		point current_pt = pts[i];
		float d = 0.0;


		// Compute the distance according to input option.
		// Note that, since we are in local space, our point is 0,0.
		if (distance_opt == 0 || distance_opt == 1) {
			// euclidean
			d = fea_length_squared(current_pt);
		} else if (distance_opt == 2) {
			// manhattan
			d = fea_distance_manhattan(point(0), current_pt);
		} else if (distance_opt == 3) {
			// chebyshev
			d = fea_distance_chebyshev(point(0), current_pt);
		} else if (distance_opt == 4) {
			// mahalanobis
			d = fea_distance_mahalanobis(point(0), pts, num_pts);
		} else if (distance_opt == 5) {
			// tests
		}

		// Whatever the metrics used, always store min to find closest point.
		if (d < min_dist) {
			min_dist = d;
			out_idx = i;
		}


		// If appropriate, compute blending.
		if (blend_opt == 1) {
			// metaballs
			if (distance_opt == 0) {
				blended_dist += pow(1.0 / d, 2.0);
			} else {
				blended_dist += pow(1.0 / (d * d), 2.0);
			}
		} else if (blend_opt == 2) {
			// exponent
			blended_dist += exp2(-blend_falloff * sqrt(d));
		} else if (blend_opt == 3) {
			// power
			blended_dist += 1.0 / pow(d, blend_falloff);
		}
	}

	// Finally, return the expected value.
	if (blend_opt == 1) {
		// return (blended_dist / float(num_pts)) < blend_falloff;
		return (blended_dist / float(num_pts)) / blend_falloff;// < blend_falloff;
	} else if (blend_opt == 2) {

	} else if (blend_opt == 3) {

	}

	if (distance_opt == 1) {
		return sqrt(min_dist);
	}
	return min_dist;

}

// Returns the distance to the closest point (from the provided points in local space).
// Also outputs the point's index.
float fea_closest_distance(point pts[], int num_pts, output int out_idx) {
	float min_dist = FEA_FLT_MAX;
	for (int i = 0; i < num_pts; ++i) {
		point current_pt = pts[i];
		float d = fea_length_squared(current_pt);
		if (d < min_dist) {
			min_dist = d;
			out_idx = i;
		}
	}
	return sqrt(min_dist);
}

// Given random points local to the currently shaded coordinate,
// returns the distance to the closest border in between closeby points (voronoi).
// Also outputs the index of the point that was used (the second closest point).
//
// Provide the index of the closest point in the point set.
float fea_voronoi_borders(int closest_idx, point pts[], int num_pts, output int second_idx) {
	point closest_pt = pts[closest_idx];
	float ret = FEA_FLT_MAX;
	for (int i = 0; i < num_pts; ++i) {
		// Skip the closest point (we are looking for second closest border).
		if (i != closest_idx) {
			point current_pt = pts[i];
			float dist_to_brdr = dot(0.5 * (closest_pt + current_pt), normalize(current_pt - closest_pt));
			if (dist_to_brdr < ret) {
				ret = dist_to_brdr;
				second_idx = i;
			}
		}
	}

	return ret;
}


shader Voronoi
[[
	string help  =
		"<h3>Voronoi</h3>"
		"An implementation of iq's voronoi algorithm. Includes corrections from tomkh and more bells and whistles.<br>"
		"<b>Warning :</b> If you connect 2d UVs, disable the '3d Evaluation' option and adjust UVW Scale."
		,
	string label = "Voronoi"
]]
(
	int in_dimensions = 3
	[[
		string label = "Dimensions",
		string help = "Evaluates the functions in 1d, 2d or 3d. The higher the dimension, the heavier the shader.<br>"
				"3d is particularly useful when rendering volumes, to eliminate seams or if your UVs contain the W component.",
		string widget = "mapper",
		string options =
			"2D:2"
			"|3D:3"
			,
		int connectable = 0,
	]],

	int in_hash_type = 0
	[[
		string label = "Hash Function",
		string help = "The core function used to generate the random points.",
		string widget = "mapper",
		string options =
			fea_hash_opts
			,
		int connectable = 0,
		// string packName = "Hash Function / Seed",
	]],

	float in_seed = 0.0
	[[
		string label = "Seed",
		string help = "A seed provided to the hash function.",
		int connectable = 0,
		// string packName = "Hash Function / Seed",
	]],


	int in_distance_type = 0
	[[
		string label = "Distance Metric",
		string help = "The distance function used to compute distance to points.",
		string widget = "mapper",
		string options =
			fea_distance_opts
			,
		int connectable = 0,
	]],

	// FEA_SPACER(0),

	int in_cell_style = 0
	[[
		string label = "Cell Style",
		string help = "The style of the cell interior.",
		string widget = "mapper",
		string options =
			"Organic:0"
			"|Bubbles:1"
			"|Chiseled:2"
			"|Color:3"
			,
		int connectable = 0,
	]],

	int in_cell_blend_type = 0
	[[
		string label = "Cell Blending",
		string help = "Various options to compute the distance of one cell to another.",
		string widget = "mapper",
		string options =
			fea_distance_blend_opts
			,
		int connectable = 0,
		string packName = "Cell Blending / Falloff",
	]],

	float in_cell_blend_falloff = 8.0
	[[
		string label = "Cell Blending Falloff",
		string help = "The strength of the cell blending.",
		float min = 0.0,
		int connectable = 0,
		string packName = "Cell Blending / Falloff",
		int widgetWidth = FEA_RPACK_W,
	]],

	int in_clamp_output = 1
	[[
		string label = "Clamp Output",
		string help = "Clamps the output value between [0..1].",
		string widget = "checkBox",
		int connectable = 0,
	]],


	// FEA_SPACER(1)

	int in_draw_borders = 0
	[[
		string label = "Draw Borders",
		string help = "Render solid voronoi cell borders.",
		string widget = "checkBox",
		int connectable = 0,
	]],

	float in_border_width = 1.0
	[[
		string label = "Border Width",
		string help = "The cell border width.",
		float min = 0.0,
	]],

	float in_border_feather = 0.01
	[[
		string label = "Border Feather",
		string help = "The cell border fade amount.",
		float min = 0.001,
	]],

	color in_border_color = color(1)
	[[
		string label = "Border Color",
		string help = "The cell border color.",
	]],

	int in_animation_type = 0
	[[
		string label = "Animation",
		string help = "Animates the points using various schemes. Pipe the scene time in the phase input to animate.",
		string widget = "mapper",
		string options =
			fea_anim_pts_opts
			,
		int connectable = 0,
	]],

	float in_phase = 0.0
	[[
		string label = "Phase",
		string help = "Used to animate or as a seed for all random functions.",
	]],

	float in_uvw_scale = 1.0
	[[
		string label = "UVW Scale",
		string help = "Scale your UVWs up or down (or the object, if no UVWs are provided).<br>For more betterer transformations, use UVW Transform node.",
		float min = 0.00001,
		int connectable = 0,
	]],

	point in_uvw = transform("object", P)
	[[
		string label = "UVW",
		string help = "Transformed UVW coordinates. Animate 'w' with scene time for interesting results.",
	]],


	output color Out = 0,
	output vector Distance = 0
)
{

/*
	feedback
	1. blender doc of voronoi node (baseline, truly understand) cool stuff : write a color, use as function to drive
	2. additional parameter, a percentage of will i use a feature point or not.
		aka, 20% of the points

	border distortion in 3d (check iq stuff)
	smoothmin (to make border "rounded")
	modulate hash vector ( exposed)
	expose phase (animate points like iq)
	blur borders (check iq article)
	perdurbe distance of borders (makes border edges ragged)
	fractal of full function
	instead of doing distance, use blob calculation (metablobs!)
	bomb implicits (sphere == blobs, super quadratic, super ellipsoid)
		bomb random rotation

	explore not f2 - f1
	other map slot to do domain distortion
		distorter map

	crazy : gradient blur?

*/

	point coord = in_uvw / in_uvw_scale;
	coord[1] = in_dimensions < 2 ? 0 : coord[1];
	coord[2] = in_dimensions < 3 ? 0 : coord[2];

	// Contains max points required.
	point rnd_pts[fea_mk_rnd_pnts_arr_size];
	int num_pts = int(pow(fea_mk_rnd_pnts_iters, in_dimensions));

	// Generate a bunch of random points, local to shaded coordinate.
	fea_make_random_points(in_dimensions, in_hash_type, in_seed, coord, rnd_pts);

	// Animate them.
	fea_animate_points(in_dimensions, in_animation_type, in_hash_type, in_phase, coord, rnd_pts, num_pts);

	// Find the closest distance to a point. Aka, voronoi.
	int closest_idx = -1;
	float dist = fea_voronoi(in_distance_type, in_cell_blend_type, in_cell_blend_falloff, rnd_pts, num_pts, closest_idx);

	// Find the distance to the closest and second closest cell border.
	int border_idx = -1;
	float border_dist = fea_voronoi_borders(closest_idx, rnd_pts, num_pts, border_idx);

	// Internal cell style
	if (in_cell_style == 0) {
		// organic
		Out = dist;
	} else if (in_cell_style == 1) {
		// bubbles
		Out = 1.0 - dist;
	} else if (in_cell_style == 2) {
		// chiseled
		Out = border_dist;
	} else if (in_cell_style == 3) {
		// color, TODO
		// temp, make global coord
		Out = (coord + rnd_pts[closest_idx]) * 0.1;
	}

	// Borders
	if (in_draw_borders) {
		float w = in_border_width * 0.1;
		float eps = in_border_feather * 0.1;
		float p = 1.0 - smoothstep(w, w + eps, border_dist);
		Out = mix(Out, in_border_color, p);
	}

	if (in_clamp_output) {
		Out = clamp(Out, color(0), color(1));
	}
}