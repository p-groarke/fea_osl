// fea_shape osl libraries by Philippe Groarke
// Copyright 2023 Philippe Groarke, All rights reserved.
// This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt
#ifndef fea_shape_osl
#define fea_shape_osl
#include "D:\code\3dsmax-plugins\OSL\FeaOSL\include\fea_functional.osl"


#define fea_shape_border_style_opts \
	"None:0" \
	"|Solid:1"

// Maybe?
struct fea_shape_style {
	int shape_feather_interp;
	float shape_feather;
	int border_style;
	float border_size;
	int border_feather_interp;
	float border_feather;
};
void fea_init(output fea_shape_style ret) {
	ret.shape_feather_interp = 0;
	ret.shape_feather = 0;
	ret.border_style = 0;
	ret.border_size = 0;
	ret.border_feather_interp = 0;
	ret.border_feather = 0;
}

// Defines properties of a shape.
struct fea_shape {
	float shape_mask; // 1.0 inside shape, 0.0 outside.
	float border_mask; // 1.0 inside border, 0.0 outside.
};
void fea_init(output fea_shape ret) {
	ret.shape_mask = 0;
	ret.border_mask = 0;
}

// Given an absolute coordinate, returns the local coordinate
// inside a grid of desired scale. This grid is aligned to the
// coordinate space.
// Ranges from [-1,-1,-1] -> [1,1,1].
point fea_grid_coord(point coord, string coord_space, float grid_scale) {
	point grid_coord = fract(coord / grid_scale);

	vector offset = vector(1);
	if (coord_space == "tangent") {
		offset = vector(1,1,0);
	}
	// else if (coord_space == "camera") {
	// Would an artist want the shapes aligned to camera?
	// Note, screen space doesn't work so that isn't available.
	// }
	return grid_coord * 2.0 - offset;
}

// Feathers the given input, according to interpolation and feather amount.
// Expects a function where surface = 0, -n inside, +n outside.
// Feathers where x < 0.
#define fea_feather_interp_opts \
	"Hermite:0" \
	"|Linear:1"

float fea_feather(float x, int interp, float amount) {
	if (amount == 0.0) {
		return 1.0 - aastep(0.0, x);
	}
	if (interp == 0) {
		// hermite
		return 1.0 - smoothstep(-amount, 0, x);
	}
	// linear
	return 1.0 - linearstep(-amount, 0, x);
}

// Given a shape function where surface = 0, -n inside, +n outside,
// applies styling.
fea_shape fea_imp_style_shape(float x, fea_shape_style style) {
	fea_shape ret;
	fea_init(ret);

	// Shape Mask
	ret.shape_mask = fea_feather(x, style.shape_feather_interp,
		style.shape_feather);

	// Border Mask
	if (style.border_style != 0 && style.border_size != 0) {
		// Where the inside of the border < 0, outside > 0.
		float border_x = abs(x) - style.border_size;
		ret.border_mask = fea_feather(border_x, style.border_feather_interp,
			style.border_feather);
	}

	return ret;
}

// Function of a sphere / circle.
fea_shape fea_sphere(point lcl, float radius, fea_shape_style style) {
	// Define a function where 0 == surface, -n inside, +n outside.
	float func(vector p) {
		return dot(p, p) - pow(radius, 2.0);
	}

#if 1
	float dist = func(lcl);
#else
	// float eps = length(filterwidth(lcl));
	float eps = 0.0001;
	float dist = fea_distance_to_func_3d(lcl, eps, func);
#endif

	// Use generalized prettify func.
	return fea_imp_style_shape(dist, style);
}
fea_shape fea_sphere(point lcl, float radius) {
	fea_shape_style style;
	fea_init(style);
	return fea_sphere(lcl, radius, style);
}


// float fea_triangle(point lcl, )

#endif