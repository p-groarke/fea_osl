// fea_functional osl libraries by Philippe Groarke
// Copyright 2022 Philippe Groarke, All rights reserved. This file is licensed under Apache 2.0 license
// https://github.com/ADN-DevTech/3dsMax-OSL-Shaders/blob/master/LICENSE.txt
#ifndef fea_functional_osl
#define fea_functional_osl

#define fea_imp_xe(eps) vector(eps, 0.0, 0.0)
#define fea_imp_ye(eps) vector(0.0, eps, 0.0)
#define fea_imp_ze(eps) vector(0.0, 0.0, eps)

// A simpler less expensive numerical gradient.
// Basically Robert's Cross.
//
// Expected func signature :
// float f(vector);
#define fea_gradient_2d(x, eps, func) \
	vector( \
		func(x + fea_imp_xe(eps)) - func(x - fea_imp_xe(eps)), \
		func(x + fea_imp_ye(eps)) - func(x - fea_imp_ye(eps)), \
		0.0 \
	) / (2.0 * eps)

// A simpler less expensive numerical 3d gradient.
// Basically Robert's Cross expanded in z.
//
// Expected func signature :
// float f(vector);
#define fea_gradient_3d(x, eps, func) \
	vector( \
		func(x + fea_imp_xe(eps)) - func(x - fea_imp_xe(eps)), \
		func(x + fea_imp_ye(eps)) - func(x - fea_imp_ye(eps)), \
		func(x + fea_imp_ze(eps)) - func(x - fea_imp_ze(eps)) \
	) / (2.0 * eps)


// Sobel operator convolution.
// Pass in a 3x3 matrix of data to convolve.
// x
// |-1| 0| 1|
// |-2| 0| 2|
// |-1| 0| 1|
// y
// |-1|-2|-1|
// | 0| 0| 0|
// | 1| 2| 1|
vector fea_sobel_gradient(matrix m) {
	float x = -m[0][0] + m[0][2] - 2 * m[1][0] + 2 * m[1][2]
			- m[2][0] + m[2][2];

	float y = -m[0][0] - 2 * m[0][1] - m[0][2]
			+ m[2][0] + 2 * m[2][1] + m[2][2];

	return vector(x, y, 0);
}

// Sharpen convolution.
// Pass in a 3x3 matrix of data to convolve.
float fea_sharpen(matrix m) {
	return -m[0][1] - m[1][0] + 5 * m[1][1] - m[1][2] - m[2][1];
}

// Blur convolution.
// Pass in a 3x3 matrix of data to convolve.
float fea_blur(matrix m) {
	return 0.0625 * (m[0][0] + m[0][2] + m[2][0] + m[2][2])
			+ 0.125 * (m[0][1] + m[1][0] + m[1][2] + m[2][1])
			+ 0.25 * m[1][1];
}

// Emboss convolution.
// Pass in a 3x3 matrix of data to convolve.
float fea_emboss(matrix m) {
	return -2 * m[0][0] - m[0][1] - m[1][0] + m[1][1] + m[1][2] + m[2][1] + 2 * m[2][2];
}

// Outline convolution.
// Pass in a 3x3 matrix of data to convolve.
float fea_outline(matrix m) {
	return -m[0][0] - m[0][1] - m[0][2] - m[1][0] + 8 * m[1][1] - m[1][2] - m[2][0] - m[2][1] - m[2][2];
}


// Computes the distance from point x to your function.
// That is : abs(f(x)) / abs(gradient(f(x)))
// https://iquilezles.org/articles/distance/
//
// Expected func signature :
// float f(vector);
#define fea_distance_field_2d(x, eps, func) \
	abs(func(x)) / length(fea_gradient_2d(x, eps, func))

// Computes the distance from point x to your function.
// That is : abs(f(x)) / abs(gradient(f(x)))
// https://iquilezles.org/articles/distance/
//
// Expected func signature :
// float f(vector);
#define fea_distance_field_3d(x, eps, func) \
	abs(func(x)) / length(fea_gradient_3d(x, eps, func))


// Fixes Max bug where an input variable cannot be used as a
// loop counter. Do the loop manually.
#define fea_imp_fractalize(lacunarity, func, out_value) \
{ \
	fea_m_norm += fea_m_amp; \
	out_value += func(fea_m_freq) * fea_m_amp; \
	fea_m_freq *= lacunarity; \
	fea_m_amp *= fea_m_inv_lacun; \
}

// Fractalizes functions.
// Calls your function with frequency to evaluate.
//
// Expected func signature :
// type f(float);
//
// Your function return type must implement the following operators :
// - add(value, value)
// - multiply(value, float)
// - divide(value, float)
//
// The answer is stored in out_value.
// WARNING : out_value MUST be initialized to 0.
//
// OTHER WARNING : This is temporarily capped at max 6 iterations,
// until the for loop bug is fixed.
#define fea_fractalize(iterations, lacunarity, func, out_value) \
{ \
	float fea_m_inv_lacun = 1.0 / lacunarity; \
	float fea_m_amp = fea_m_inv_lacun; \
	float fea_m_freq = 1.0; \
	float fea_m_norm = 0.0; \
	if (iterations >= 1) fea_imp_fractalize(lacunarity, func, out_value) \
	if (iterations >= 2) fea_imp_fractalize(lacunarity, func, out_value) \
	if (iterations >= 3) fea_imp_fractalize(lacunarity, func, out_value) \
	if (iterations >= 4) fea_imp_fractalize(lacunarity, func, out_value) \
	if (iterations >= 5) fea_imp_fractalize(lacunarity, func, out_value) \
	if (iterations >= 6) fea_imp_fractalize(lacunarity, func, out_value) \
	if (iterations >= 1) { \
		out_value /= fea_m_norm; \
	} \
}

// Backup
// #define fea_fractalize(iterations, lacunarity, func, out_value) \
// { \
// 	if (iterations >= 1) { \
// 		float fea_m_inv_lacun = 1.0 / lacunarity; \
// 		float fea_m_amp = fea_m_inv_lacun; \
// 		float fea_m_freq = 1.0; \
// 		float fea_m_norm = 0.0; \
// 		for (int fea_m_i = 0; fea_m_i < iterations; ++fea_m_i) { \
// 			fea_m_norm += fea_m_amp; \
// 			out_value += func(fea_m_freq) * fea_m_amp; \
// 			fea_m_freq *= lacunarity; \
// 			fea_m_amp *= fea_m_inv_lacun; \
// 		} \
// 		out_value /= fea_m_norm; \
// 	} \
// }

#endif // fea_functional_osl